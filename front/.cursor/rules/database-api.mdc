# Database & API Rules

## âš ï¸ í•„ìˆ˜ í™•ì¸ì‚¬í•­

**ë°ì´í„°ë² ì´ìŠ¤ ê´€ë ¨ ì‘ì—…ì„ ì‹œì‘í•˜ê¸° ì „ì— ë°˜ë“œì‹œ ë‹¤ìŒ íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”:**

ğŸ“ **`front/src/shared/types/database.ts`**

ì´ íŒŒì¼ì€ Supabaseì—ì„œ ìë™ ìƒì„±ëœ **ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ**ì…ë‹ˆë‹¤.
- ëª¨ë“  í…Œì´ë¸” êµ¬ì¡°ì™€ íƒ€ì… ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤
- ì¶”ì¸¡ì´ë‚˜ ê°€ì • ëŒ€ì‹  **ì´ íŒŒì¼ì„ ê¸°ì¤€**ìœ¼ë¡œ ì‘ì—…í•˜ì„¸ìš”
- ìƒˆë¡œìš´ ê¸°ëŠ¥ êµ¬í˜„ ì‹œ ë°˜ë“œì‹œ ì´ íŒŒì¼ë¶€í„° í™•ì¸í•˜ì„¸ìš”

```typescript
// âœ… ì˜¬ë°”ë¥¸ ë°©ë²•: database.tsì—ì„œ ì‹¤ì œ ìŠ¤í‚¤ë§ˆ í™•ì¸
import type { Tables } from '@/shared/types/database';
type TodoItem = Tables<'tb_todolist'>; // ì‹¤ì œ ìŠ¤í‚¤ë§ˆ í™œìš©

// âŒ ì˜ëª»ëœ ë°©ë²•: ì¶”ì¸¡ìœ¼ë¡œ íƒ€ì… ì •ì˜
interface TodoItem {
  id: number;
  created_at: string;
  // ë‹¤ë¥¸ í•„ë“œë“¤ì´ ìˆì„ ìˆ˜ ìˆìŒ!
}
```

## ğŸ—‘ï¸ Soft Delete ì •ì±… (í•„ìˆ˜ ì¤€ìˆ˜)

**ëª¨ë“  í…Œì´ë¸”ì— `deleted_at` í•„ë“œê°€ ìˆëŠ” ê²½ìš° ë°˜ë“œì‹œ Soft Deleteë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.**

### ê¸°ë³¸ ì›ì¹™
```typescript
// âœ… ì¡°íšŒ ì‹œ: deleted_atì´ nullì¸ ë ˆì½”ë“œë§Œ ì¡°íšŒ
query = query.where('deleted_at', 'is', null);

// âœ… ì‚­ì œ ì‹œ: deleted_atì— í˜„ì¬ ì‹œê°„ ì„¤ì • (Soft Delete)
updateTodo.mutate({
  id: todoId,
  data: { deleted_at: new Date().toISOString() }
});

// âŒ ì ˆëŒ€ ê¸ˆì§€: ì‹¤ì œ DELETE ì‚¬ìš©
// deleteTodo.mutate({ id: todoId }); // ì‚¬ìš© ê¸ˆì§€!
```

### Query Builderì—ì„œ Soft Delete ì ìš©
```typescript
// ëª¨ë“  ì¡°íšŒ ì¿¼ë¦¬ì— ìë™ìœ¼ë¡œ deleted_at í•„í„° ì ìš©
const activeTodosQuery = createSupabaseQuery('tb_todolist')
  .select('*')
  .where('deleted_at', 'is', null) // í•„ìˆ˜!
  .orderByDesc('created_at');

// ì—…ë°ì´íŠ¸ ì‹œì—ë„ ì‚­ì œë˜ì§€ ì•Šì€ ë ˆì½”ë“œë§Œ ëŒ€ìƒ
const updateQuery = createSupabaseQuery('tb_todolist')
  .update({ title: 'new title', updated_at: new Date().toISOString() })
  .where('id', 'eq', todoId)
  .where('deleted_at', 'is', null); // í•„ìˆ˜!
```

### ì‚­ì œ í•¨ìˆ˜ íŒ¨í„´
```typescript
// âœ… Soft Delete í•¨ìˆ˜
const softDeleteTodo = (todoId: string) => {
  updateTodo.mutate({
    id: todoId,
    data: {
      deleted_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    }
  });
};

// ğŸ”§ Hard Delete (ê´€ë¦¬ì ì „ìš©, íŠ¹ë³„í•œ ê²½ìš°ë§Œ)
const hardDeleteTodo = (todoId: string) => {
  // ì¼ë°˜ ì‚¬ìš©ìëŠ” ì‚¬ìš© ê¸ˆì§€
  // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸ í›„ì—ë§Œ ì‚¬ìš©
  if (!isAdmin) throw new Error('ê¶Œí•œ ì—†ìŒ');
  deleteTodo.mutate({ id: todoId });
};
```

## Supabase ìŠ¤í‚¤ë§ˆ ë° ì„¤ì •

### ë°ì´í„°ë² ì´ìŠ¤ íƒ€ì… ìƒì„±
```bash
# Supabase ìŠ¤í‚¤ë§ˆì—ì„œ TypeScript íƒ€ì… ìë™ ìƒì„±
npm run supabase:types
```

ì´ ëª…ë ¹ì–´ëŠ” `src/shared/types/database.ts`ì— íƒ€ì…ì„ ìƒì„±í•©ë‹ˆë‹¤.

### Supabase í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
```typescript
// src/shared/api/supabase.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/shared/types/database';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// í™˜ê²½ ë³€ìˆ˜ ê²€ì¦ (í•„ìˆ˜)
if (!supabaseUrl || !supabaseKey) {
  throw new Error('VITE_SUPABASE_URLê³¼ VITE_SUPABASE_ANON_KEY í™˜ê²½ë³€ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
}

// íƒ€ì… ì•ˆì „í•œ í´ë¼ì´ì–¸íŠ¸ ìƒì„±
export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
  },
});
```

## Database.ts í™œìš©ë²•

### íƒ€ì… ì¶”ì¶œ ë° ì‚¬ìš©
```typescript
import type { Database, Tables, TablesInsert, TablesUpdate } from '@/shared/types/database';

// í…Œì´ë¸” Row íƒ€ì… ì¶”ì¶œ
type TodoItem = Tables<'tb_todolist'>;
type User = Tables<'users'>;

// Insert íƒ€ì… ì¶”ì¶œ (ìë™ ìƒì„± í•„ë“œ ì œì™¸)
type NewTodoItem = TablesInsert<'tb_todolist'>;

// Update íƒ€ì… ì¶”ì¶œ (ë¶€ë¶„ ì—…ë°ì´íŠ¸)
type TodoItemUpdate = TablesUpdate<'tb_todolist'>;

// ì‚¬ìš© ì˜ˆì‹œ
const createTodo = async (todo: NewTodoItem): Promise<TodoItem> => {
  const { data, error } = await supabase
    .from('tb_todolist')
    .insert(todo)
    .select()
    .single();

  if (error) throw error;
  return data;
};
```

## API íŒ¨í„´

### API ì‘ë‹µ ë˜í¼
```typescript
// src/shared/api/client.ts

// í†µì¼ëœ API ì‘ë‹µ í˜•íƒœ
export interface ApiResponse<T = unknown> {
  data: T;
  message?: string;
  status: number;
}

// API ë˜í¼ í•¨ìˆ˜ - ëª¨ë“  Supabase ìš”ì²­ì— ì‚¬ìš©
export const apiWrapper = async <T>(
  request: () => Promise<{ data: T; error: unknown }>
): Promise<ApiResponse<T>> => {
  try {
    const { data, error } = await request();
    
    if (error) {
      // Supabase ì—ëŸ¬ íƒ€ì…ë³„ ì²˜ë¦¬
      if (isAuthError(error)) {
        throw ApiException.fromAuthError(error);
      }
      
      if (error && typeof error === 'object' && 'code' in error) {
        throw ApiException.fromPostgrestError(error as PostgrestError);
      }
      
      throw new ApiException(400, 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }

    return { data, status: 200, message: 'success' };
  } catch (error) {
    if (error instanceof ApiException) throw error;
    throw new ApiException(500, 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
  }
};
```

### API ì—ëŸ¬ í´ë˜ìŠ¤
```typescript
export class ApiException extends Error {
  public status: number;
  public code?: string;
  public details?: unknown;
  public hint?: string;

  // Supabase AuthError ë³€í™˜
  static fromAuthError(error: AuthError): ApiException {
    const statusMap: Record<string, number> = {
      'invalid_credentials': 401,
      'email_not_confirmed': 422,
      'signup_disabled': 403,
      'weak_password': 400,
      'rate_limit_exceeded': 429,
    };

    return new ApiException(
      statusMap[error.message] || 400,
      error.message,
      error.message,
      error
    );
  }

  // Supabase PostgrestError ë³€í™˜
  static fromPostgrestError(error: PostgrestError): ApiException {
    return new ApiException(400, error.message, error.code, error.details, error.hint);
  }
}
```

### CRUD API íŒ¨í„´
```typescript
// íƒ€ì… ì•ˆì „í•œ CRUD API ìƒì„± íŒ©í† ë¦¬
export const createCrudApi = <T extends Record<string, any>>(tableName: string) => {
  return {
    findAll: async (): Promise<ApiResponse<T[]>> => {
      const response = await supabase.from(tableName).select('*');
      return apiWrapper(() => Promise.resolve(response));
    },
      
    findById: async (id: string): Promise<ApiResponse<T>> => {
      const response = await supabase.from(tableName).select('*').eq('id', id).single();
      return apiWrapper(() => Promise.resolve(response));
    },
      
    create: async (data: Omit<T, 'id' | 'created_at' | 'updated_at'>): Promise<ApiResponse<T>> => {
      const response = await supabase.from(tableName).insert(data).select().single();
      return apiWrapper(() => Promise.resolve(response));
    },
      
    update: async (id: string, data: Partial<T>): Promise<ApiResponse<T>> => {
      const response = await supabase.from(tableName).update(data).eq('id', id).select().single();
      return apiWrapper(() => Promise.resolve(response));
    },
      
    delete: async (id: string): Promise<ApiResponse<void>> => {
      const response = await supabase.from(tableName).delete().eq('id', id);
      return apiWrapper(() => Promise.resolve(response));
    },
  };
};

// ì‚¬ìš© ì˜ˆì‹œ
type TodoItem = Tables<'tb_todolist'>;
export const todoApi = createCrudApi<TodoItem>('tb_todolist');
```

## Query Builder íŒ¨í„´

### Supabase Query Builder ì‚¬ìš©
```typescript
// src/domains/supabaseCommon/hooks/useSupabaseQuery.ts

// ì²´ì´ë‹ ê°€ëŠ¥í•œ Query Builder
export const createSupabaseQuery = <T = unknown>(table: string): SupabaseQueryBuilder<T> => {
  return new SupabaseQueryBuilder<T>(table);
};

// ê¸°ë³¸ ì‚¬ìš© ì˜ˆì‹œ
const usersQuery = createSupabaseQuery('users')
  .select('id, name, email, avatar_url')
  .where('status', 'eq', 'active')
  .search(['name', 'email'], searchTerm)
  .paginate({ page: 0, size: 20 })
  .sort('created_at', 'desc');

// TanStack Queryì™€ í†µí•©
const { data: users, isLoading } = useSupabaseQueryBuilder(usersQuery, {
  enabled: !!searchTerm
});
```

### ì¡°ê±´ë¶€ ì¿¼ë¦¬ ìƒì„±
```typescript
const createConditionalQuery = <T = unknown>(
  table: string,
  conditions: {
    select?: string;
    where?: Array<{ column: string; operator: string; value: unknown }>;
    search?: { columns: string[]; term: string };
    sort?: Array<{ column: string; direction: 'asc' | 'desc' }>;
    pagination?: { page: number; size: number };
    single?: boolean;
  }
): SupabaseQueryBuilder<T> => {
  // ì¡°ê±´ì— ë”°ë¼ ë™ì  ì¿¼ë¦¬ ìƒì„±
};
```

## ì—ëŸ¬ í•¸ë“¤ë§

### PostgreSQL ì—ëŸ¬ ì½”ë“œ ë§¤í•‘
```typescript
export const handleSupabaseError = (error: unknown): never => {
  if (error && typeof error === 'object' && 'code' in error) {
    const pgError = error as PostgrestError;
    
    switch (pgError.code) {
      case '23505': // unique_violation
        throw new ApiException(409, 'ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.');
      case '23503': // foreign_key_violation
        throw new ApiException(400, 'ì°¸ì¡°ëœ ë°ì´í„°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
      case '42501': // insufficient_privilege
        throw new ApiException(403, 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.');
      case '23514': // check_violation
        throw new ApiException(400, 'ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
      default:
        throw new ApiException(400, pgError.message, pgError.code);
    }
  }
  
  throw new ApiException(500, 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
};
```

## RLS (Row Level Security) ì ìš©

### RLS ì •ì±… ì˜ˆì‹œ (SQL)
```sql
-- í…Œì´ë¸”ì— RLS í™œì„±í™”
ALTER TABLE todos ENABLE ROW LEVEL SECURITY;

-- ì‚¬ìš©ìëŠ” ìì‹ ì˜ ë°ì´í„°ë§Œ ì ‘ê·¼ ê°€ëŠ¥
CREATE POLICY "Users can manage own data" ON todos
  USING (auth.uid() = user_id);
```

### RLS ì ìš© ì‹œ í”„ë¡ íŠ¸ì—”ë“œ íŒ¨í„´
```typescript
// ì¸ì¦ëœ ìƒíƒœì—ì„œë§Œ ë°ì´í„° ì ‘ê·¼
const { user } = useAuth();

const todosQuery = createSupabaseQuery('todos')
  .select('*')
  .where('user_id', 'eq', user?.id) // RLSê°€ ìë™ìœ¼ë¡œ í•„í„°ë§í•˜ì§€ë§Œ ëª…ì‹œì  ì¶”ê°€ ê¶Œì¥
  .sort('created_at', 'desc');

const { data: todos } = useSupabaseQueryBuilder(todosQuery, {
  enabled: !!user // ì¸ì¦ëœ ì‚¬ìš©ìë§Œ ì¿¼ë¦¬ ì‹¤í–‰
});
```

## ì‹¤ì‹œê°„ êµ¬ë… ì„¤ì •

### Realtime êµ¬ë… íŒ¨í„´
```typescript
// í…Œì´ë¸” ë³€ê²½ ì‚¬í•­ êµ¬ë…
useEffect(() => {
  if (!user) return;

  const subscription = supabase
    .channel('todos-changes')
    .on('postgres_changes', {
      event: '*', // INSERT, UPDATE, DELETE
      schema: 'public',
      table: 'todos',
      filter: `user_id=eq.${user.id}` // ì‚¬ìš©ì ë°ì´í„°ë§Œ êµ¬ë…
    }, (payload) => {
      console.log('Real-time change:', payload);
      
      // TanStack Query ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    })
    .subscribe();

  return () => subscription.unsubscribe();
}, [user?.id, queryClient]);
```

## Query Key ê´€ë¦¬

### í‘œì¤€í™”ëœ Query Key íŒ¨í„´
```typescript
export const createQueryKeys = (entity: string) => ({
  all: () => [entity] as const,
  lists: () => [...createQueryKeys(entity).all(), 'list'] as const,
  list: (filters: Record<string, unknown>) => 
    [...createQueryKeys(entity).lists(), filters] as const,
  details: () => [...createQueryKeys(entity).all(), 'detail'] as const,
  detail: (id: string) => [...createQueryKeys(entity).details(), id] as const,
});

// ê³µí†µ Query Keys
export const QUERY_KEYS = {
  users: createQueryKeys('users'),
  todos: createQueryKeys('todos'),
  posts: createQueryKeys('posts'),
} as const;

// ì‚¬ìš© ì˜ˆì‹œ
const userKeys = QUERY_KEYS.users;
userKeys.all()                    // ['users']
userKeys.detail('123')            // ['users', 'detail', '123']
```

## ê°œë°œ ì›Œí¬í”Œë¡œìš°

### 1. ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì‹œ
```bash
# 1. Supabaseì—ì„œ ìŠ¤í‚¤ë§ˆ ë³€ê²½
# 2. íƒ€ì… ì¬ìƒì„±
npm run supabase:types
# 3. ê´€ë ¨ API ì½”ë“œ ì—…ë°ì´íŠ¸
```

### 2. ìƒˆ í…Œì´ë¸” ì¶”ê°€ ì‹œ
```typescript
// 1. database.ts íƒ€ì… í™•ì¸
// 2. CRUD API ìƒì„±
export const newTableApi = createCrudApi<Tables<'new_table'>>('new_table');

// 3. Query Keys ì¶”ê°€
export const QUERY_KEYS = {
  // ... ê¸°ì¡´ í‚¤ë“¤
  newTable: createQueryKeys('new_table'),
} as const;
```

### 3. ë³µí•© ì¿¼ë¦¬ ì‘ì„± ì‹œ
```typescript
// 1. Query Builder í™œìš©
const complexQuery = createSupabaseQuery('posts')
  .select(`
    *,
    users!posts_author_id_fkey(id, name, avatar_url),
    categories!posts_category_id_fkey(id, name)
  `)
  .where('status', 'eq', 'published')
  .search(['title', 'content'], searchTerm)
  .paginate({ page: 0, size: 10 });

// 2. TanStack Queryì™€ í†µí•©
const { data: posts } = useSupabaseQueryBuilder(complexQuery);
```