---
globs: ["**/ui/**/*.tsx", "**/ui/**/*.ts"]
alwaysApply: true
---

# Vibe 프로젝트 UI 컴포넌트 가이드

> 기존 컴포넌트를 최대한 활용하여 중복 개발을 방지하고 일관성을 유지하기 위한 가이드

## 🧩 기존 UI 컴포넌트 인벤토리

### 📦 Form Components

#### Button (`@/shared/ui/Button`)
```typescript
variant: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger'
size: 'sm' | 'md' | 'lg'
// 추가 기능
fullWidth?: boolean
loading?: boolean
startIcon?: ReactNode
endIcon?: ReactNode
```

**사용 시나리오:**
- `primary`: 메인 액션 (저장, 제출, 확인)
- `secondary`: 보조 액션 (취소, 닫기)
- `outline`: 중요하지 않은 액션 (더보기, 편집)
- `ghost`: 최소한의 액션 (링크, 텍스트 버튼)
- `danger`: 위험한 액션 (삭제, 제거)

#### Input (`@/shared/ui/Input`)
```typescript
size: 'sm' | 'md' | 'lg'
// 추가 기능
label?: string
error?: string
helperText?: string
fullWidth?: boolean
startIcon?: ReactNode
endIcon?: ReactNode
```

**확장 가능성:**
- TextArea, Select, Checkbox, Radio 등은 Input 패턴 확장 권장

### 🏗️ Layout Components

#### Container (`@/shared/ui/Layout`)
```typescript
size: 'sm' | 'md' | 'lg' | 'xl' | 'full'
```

#### Grid (`@/shared/ui/Layout`)
```typescript
cols: 1 | 2 | 3 | 4 | 6 | 12
gap: 'sm' | 'md' | 'lg'
```

#### Flex (`@/shared/ui/Layout`)
```typescript
direction: 'row' | 'column'
align: 'start' | 'center' | 'end' | 'stretch'
justify: 'start' | 'center' | 'end' | 'between' | 'around' | 'evenly'
wrap?: boolean
gap: 'sm' | 'md' | 'lg'
```

#### Header (`@/shared/ui/Header`)
- 네비게이션, 로고, 액션 버튼 포함
- 반응형 메뉴 지원

#### Footer (`@/shared/ui/Footer`)
- 링크 섹션, 저작권 정보 포함
- 반응형 레이아웃

## 🔄 새 컴포넌트 vs 기존 확장 결정 가이드

### ✅ 기존 컴포넌트 확장하는 경우

#### 1. 새로운 variant 추가
```typescript
// Button에 'success' variant 추가하고 싶다면
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger' | 'success'; // ✅ 확장
}
```

#### 2. 새로운 size 추가
```typescript
// Input에 'xs' size 추가하고 싶다면
interface InputProps {
  size?: 'xs' | 'sm' | 'md' | 'lg'; // ✅ 확장
}
```

#### 3. 기존 패턴과 80% 이상 유사한 경우
```typescript
// TextArea는 Input의 확장
interface TextAreaProps extends Omit<InputProps, 'type'> {
  rows?: number;
  maxLength?: number;
}
```

### 🆕 새로운 컴포넌트 만드는 경우

#### 1. 완전히 다른 UI 패턴
```typescript
// Modal, Dropdown, Carousel 등
// 기존 컴포넌트와 전혀 다른 UX
```

#### 2. 복합 컴포넌트
```typescript
// UserCard, ProductCard 등
// 여러 기본 컴포넌트를 조합한 복합 컴포넌트
```

#### 3. 특수한 비즈니스 로직
```typescript
// PaymentForm, SearchBox 등
// 도메인 특화 기능이 강한 컴포넌트
```

## 🎨 공통 Props 패턴

### 기본 Props (모든 컴포넌트 공통)
```typescript
interface BaseComponentProps {
  className?: string;
  testId?: string;
  children?: ReactNode;
}
```

### Size Props (크기 조절 가능한 컴포넌트)
```typescript
type Size = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
```

### Variant Props (스타일 변형 가능한 컴포넌트)
```typescript
type Variant = 'primary' | 'secondary' | 'danger' | 'success' | 'warning';
```

### State Props (상태 표시 컴포넌트)
```typescript
interface StateProps {
  loading?: boolean;
  disabled?: boolean;
  error?: boolean;
}
```

## 🔗 컴포넌트 조합 패턴

### 1. 카드형 컴포넌트 조합
```typescript
// ✅ 기존 컴포넌트 조합 활용
const UserCard = ({ user }: UserCardProps) => (
  <Container size="sm" className={styles.card}>
    <Flex direction="column" gap="md">
      <Flex align="center" gap="sm">
        <img src={user.avatar} alt="" className={styles.avatar} />
        <div>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      </Flex>
      <Flex gap="sm">
        <Button variant="primary" size="sm">팔로우</Button>
        <Button variant="outline" size="sm">메시지</Button>
      </Flex>
    </Flex>
  </Container>
);
```

### 2. 폼 컴포넌트 조합
```typescript
// ✅ 폼 레이아웃 패턴
const LoginForm = () => (
  <Container size="sm">
    <Flex direction="column" gap="lg">
      <Input 
        label="이메일" 
        type="email" 
        fullWidth 
        error={emailError}
      />
      <Input 
        label="비밀번호" 
        type="password" 
        fullWidth 
        error={passwordError}
      />
      <Flex gap="sm">
        <Button variant="primary" fullWidth loading={isLoading}>
          로그인
        </Button>
        <Button variant="outline" fullWidth>
          취소
        </Button>
      </Flex>
    </Flex>
  </Container>
);
```

### 3. 리스트 컴포넌트 조합
```typescript
// ✅ 그리드 레이아웃 활용
const ProductGrid = ({ products }: ProductGridProps) => (
  <Container>
    <Grid cols={3} gap="lg">
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </Grid>
  </Container>
);
```

## 📝 컴포넌트 네이밍 가이드

### 1. 기본 컴포넌트 (shared/ui)
```typescript
// ✅ 일반적인 이름 사용
Button, Input, Modal, Card, Badge, Avatar
```

### 2. 비즈니스 컴포넌트 (entities)
```typescript
// ✅ 도메인 + 컴포넌트 타입
UserCard, ProductItem, OrderSummary
```

### 3. 기능 컴포넌트 (features)
```typescript
// ✅ 기능 + Form/List/Card 등
LoginForm, SearchBox, CartSummary
```

### 4. 위젯 컴포넌트 (widgets)
```typescript
// ✅ 위치나 역할 기반
Header, Footer, Sidebar, Navigation
```

## 🔍 컴포넌트 선택 결정 트리

### 질문 1: "어떤 기능이 필요한가?"

#### 버튼이 필요하다면?
1. **기본 액션** → `Button` (variant 선택)
2. **링크 역할** → `Button variant="ghost"` 또는 `Link`
3. **아이콘만** → `Button` (children에 아이콘만)

#### 입력 필드가 필요하다면?
1. **텍스트 입력** → `Input`
2. **여러 줄 입력** → `Input` 확장해서 `TextArea` 생성
3. **선택 입력** → `Input` 패턴 따라 `Select` 생성

#### 레이아웃이 필요하다면?
1. **컨테이너** → `Container`
2. **그리드 배치** → `Grid`
3. **플렉스 배치** → `Flex`
4. **페이지 전체** → `Layout`

### 질문 2: "비슷한 컴포넌트가 있는가?"

#### 있다면:
1. 기존 컴포넌트의 props 확장 검토
2. variant나 size 추가로 해결 가능한지 확인
3. 새로운 props 추가로 해결 가능한지 확인

#### 없다면:
1. 여러 기존 컴포넌트 조합으로 해결 가능한지 확인
2. 정말 새로운 컴포넌트가 필요한지 재검토
3. 적절한 FSD 레이어에 배치

## 📋 컴포넌트 개발 체크리스트

### 개발 전 확인
- [ ] 기존 컴포넌트로 해결 가능한가?
- [ ] 기존 컴포넌트 확장으로 해결 가능한가?
- [ ] 여러 컴포넌트 조합으로 해결 가능한가?
- [ ] 정말 새로운 컴포넌트가 필요한가?

### 개발 중 확인
- [ ] 기존 Props 패턴을 따르고 있는가?
- [ ] 네이밍이 일관성 있는가?
- [ ] 재사용 가능하게 설계되었는가?
- [ ] 적절한 레이어에 배치되었는가?

### 개발 후 확인
- [ ] 다른 곳에서도 사용할 수 있는가?
- [ ] 기존 디자인 시스템과 일관성이 있는가?
- [ ] 접근성이 고려되었는가?
- [ ] 성능에 문제가 없는가?

## 💡 효율적인 컴포넌트 활용 팁

1. **먼저 찾기**: 새로 만들기 전에 기존 컴포넌트 인벤토리 확인
2. **조합 우선**: 단일 컴포넌트보다 기존 컴포넌트 조합 고려
3. **점진적 확장**: 한 번에 많은 기능보다 단계적 확장
4. **일관성 유지**: 기존 패턴과 네이밍 컨벤션 준수
5. **문서화**: 새로운 컴포넌트는 사용 예시와 함께 문서화

이 가이드를 통해 중복 개발을 방지하고 일관성 있는 UI 컴포넌트를 개발할 수 있습니다.

## 🔧 ESLint 기반 UI 컴포넌트 개발 룰

### 📝 컴포넌트 파일 구조 규칙

#### 1. **파일 네이밍 컨벤션**
```typescript
// ✅ 올바른 파일명
Button.tsx, Button.module.scss
UserCard.tsx, UserCard.module.scss  
LoginForm.tsx, LoginForm.module.scss

// ❌ 잘못된 파일명
button.tsx, usercard.tsx
login-form.tsx, Login_Form.tsx
```

#### 2. **컴포넌트 Export 패턴**
```typescript
// ✅ Named export 사용 (필수)
export const Button: React.FC<ButtonProps> = ({ children, ...props }) => {
  return <button {...props}>{children}</button>;
};

// ❌ Default export 금지
export default Button;
```

#### 3. **Props 타입 정의**
```typescript
// ✅ 인터페이스로 Props 정의 (필수)
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
  children: ReactNode;
  onClick?: () => void;
}

// ❌ Type alias 사용 금지
type ButtonProps = {
  // ...
};
```

### 🎨 스타일링 ESLint 룰

#### 1. **CSS Modules 사용 강제**
```typescript
// ✅ CSS Modules import 필수
import styles from './Button.module.scss';

export const Button = () => (
  <button className={styles.button}>
    Click me
  </button>
);

// ❌ 인라인 스타일 금지
export const Button = () => (
  <button style={{ color: 'red' }}>
    Click me
  </button>
);
```

#### 2. **className 조합 패턴**
```typescript
// ✅ clsx 또는 조건부 클래스 사용
import styles from './Button.module.scss';

export const Button = ({ variant, disabled }: ButtonProps) => (
  <button 
    className={`${styles.button} ${styles[variant]} ${disabled ? styles.disabled : ''}`}
  >
    Click me
  </button>
);

// ✅ 또는 clsx 사용 (권장)
import clsx from 'clsx';
import styles from './Button.module.scss';

export const Button = ({ variant, disabled }: ButtonProps) => (
  <button 
    className={clsx(styles.button, styles[variant], {
      [styles.disabled]: disabled
    })}
  >
    Click me
  </button>
);
```

### ♿ 접근성 ESLint 룰

#### 1. **필수 접근성 속성**
```typescript
// ✅ 접근성 속성 포함 필수
export const Button = ({ children, loading, ...props }: ButtonProps) => (
  <button 
    {...props}
    aria-disabled={loading}
    aria-label={loading ? '로딩 중...' : undefined}
  >
    {children}
  </button>
);

// ✅ 이미지에 alt 속성 필수
export const Avatar = ({ src, name }: AvatarProps) => (
  <img src={src} alt={`${name}의 프로필 이미지`} />
);
```

#### 2. **키보드 내비게이션 지원**
```typescript
// ✅ 키보드 이벤트 핸들러 포함
export const Modal = ({ onClose }: ModalProps) => {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };
    
    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [onClose]);

  return (
    <div role="dialog" aria-modal="true">
      {/* Modal content */}
    </div>
  );
};
```

### ⚡ 성능 ESLint 룰

#### 1. **불필요한 리렌더링 방지**
```typescript
// ✅ React.memo 사용 (필요한 경우)
export const ExpensiveComponent = React.memo<ExpensiveComponentProps>(
  ({ data, onUpdate }) => {
    return (
      <div>
        {/* 복잡한 렌더링 로직 */}
      </div>
    );
  }
);

// ✅ useCallback 사용 (필요한 경우)
export const ParentComponent = () => {
  const [items, setItems] = useState([]);
  
  const handleItemClick = useCallback((id: string) => {
    setItems(prev => prev.filter(item => item.id !== id));
  }, []);

  return (
    <div>
      {items.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onClick={handleItemClick}
        />
      ))}
    </div>
  );
};
```

#### 2. **Props 구조분해 패턴**
```typescript
// ✅ Props 구조분해 사용
export const Button = ({ 
  variant = 'primary', 
  size = 'md', 
  loading = false,
  children,
  ...restProps 
}: ButtonProps) => {
  return (
    <button 
      className={clsx(styles.button, styles[variant], styles[size])}
      disabled={loading}
      {...restProps}
    >
      {loading ? <Spinner /> : children}
    </button>
  );
};

// ❌ props 객체 직접 사용 금지
export const Button = (props: ButtonProps) => {
  return (
    <button className={styles.button}>
      {props.children}
    </button>
  );
};
```

### 🏗️ 컴포넌트 구조 ESLint 룰

#### 1. **컴포넌트 크기 제한**
```typescript
// ✅ 50줄 이하 권장 (ESLint: max-lines-per-function)
export const Button = ({ variant, children }: ButtonProps) => {
  return (
    <button className={clsx(styles.button, styles[variant])}>
      {children}
    </button>
  );
};

// ❌ 너무 긴 컴포넌트는 분리 필요
export const VeryLongComponent = () => {
  // 100줄 이상의 복잡한 로직
  // → 여러 컴포넌트로 분리 필요
};
```

#### 2. **Hook 사용 순서**
```typescript
// ✅ Hook 사용 순서 준수
export const Component = () => {
  // 1. useState
  const [state, setState] = useState(initial);
  
  // 2. useEffect
  useEffect(() => {
    // effect logic
  }, []);
  
  // 3. Custom hooks
  const { data, loading } = useCustomHook();
  
  // 4. Event handlers
  const handleClick = () => {
    setState(newValue);
  };
  
  // 5. Render
  return <div onClick={handleClick}>{data}</div>;
};
```

### 📦 Import/Export ESLint 룰

#### 1. **Import 순서**
```typescript
// ✅ Import 순서 준수
// 1. React 및 외부 라이브러리
import React, { useState, useEffect } from 'react';
import clsx from 'clsx';

// 2. 내부 컴포넌트 (상위 → 하위 레이어)
import { Container } from '@/shared/ui/Layout';
import { User } from '@/entities/user';

// 3. 스타일 및 타입
import styles from './Component.module.scss';
import type { ComponentProps } from './types';
```

#### 2. **절대 경로 사용 강제**
```typescript
// ✅ 절대 경로 사용 (필수)
import { Button } from '@/shared/ui/Button';
import { useAuth } from '@/shared/hooks/useAuth';

// ❌ 상대 경로 금지
import { Button } from '../../../shared/ui/Button';
import { useAuth } from '../../../shared/hooks/useAuth';
```

이러한 ESLint 룰을 통해 일관성 있고 품질 높은 UI 컴포넌트를 개발할 수 있습니다.