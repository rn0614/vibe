
# Vibe 프로젝트 Atomic Design UI 컴포넌트 가이드

> 기존 Atomic Design 컴포넌트를 최대한 활용하여 중복 개발을 방지하고 일관성을 유지하기 위한 가이드

## 🧩 기존 Atomic Design 컴포넌트 인벤토리

### 📦 Atoms (기본 UI 요소)

#### Button (`@/components/atoms/Button`)
```typescript
variant: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger'
size: 'sm' | 'md' | 'lg'
// 추가 기능
fullWidth?: boolean
loading?: boolean
startIcon?: ReactNode
endIcon?: ReactNode
```

**사용 시나리오:**
- `primary`: 메인 액션 (저장, 제출, 확인)
- `secondary`: 보조 액션 (취소, 닫기)
- `outline`: 중요하지 않은 액션 (더보기, 편집)
- `ghost`: 최소한의 액션 (링크, 텍스트 버튼)
- `danger`: 위험한 액션 (삭제, 제거)

#### Input (`@/components/atoms/Input`)
```typescript
size: 'sm' | 'md' | 'lg'
// 추가 기능
label?: string
error?: string
helperText?: string
fullWidth?: boolean
startIcon?: ReactNode
endIcon?: ReactNode
```

**확장 가능성:**
- TextArea, Select, Checkbox, Radio 등은 Input 패턴 확장 권장

#### IconButton (`@/components/atoms/IconButton`)
```typescript
icon: string | ReactNode
size?: 'sm' | 'md' | 'lg'
variant?: 'primary' | 'secondary' | 'ghost'
```

#### Layout (`@/components/atoms/Layout`)
```typescript
// Container, Grid, Flex 등의 레이아웃 유틸리티
```

#### Logo (`@/components/atoms/Logo`)
```typescript
size?: 'sm' | 'md' | 'lg'
variant?: 'light' | 'dark'
```

### 🔗 Molecules (atoms 조합)

#### AuthActions (`@/components/molecules/AuthActions`)
```typescript
// 로그인/회원가입 버튼 조합
onLogin?: () => void
onSignup?: () => void
```

#### UserDropdown (`@/components/molecules/UserDropdown`)
```typescript
userEmail: string
onSignOut: () => void
isSigningOut?: boolean
```

#### ThemeToggle (`@/components/molecules/ThemeToggle`)
```typescript
// 테마 전환 토글
```

#### NavigationItem (`@/components/molecules/NavigationItem`)
```typescript
// 네비게이션 아이템
```

#### HeaderLeft (`@/components/molecules/HeaderLeft`)
```typescript
onMenuToggle: () => void
```

### 🧩 Organisms (molecules 조합)

#### AppHeader (`@/components/organisms/AppHeader`)
- HeaderLeft + ThemeToggle + UserDropdown/AuthActions 조합
- 전체 헤더 레이아웃과 상태 관리

#### AppSidebar (`@/components/organisms/AppSidebar`)
- 네비게이션 메뉴와 사이드바 레이아웃

#### AuthUI (`@/components/organisms/AuthUI`)
- 인증 관련 UI 컴포넌트

### 📄 Templates (페이지 레이아웃)

#### MainLayout (`@/components/templates/MainLayout`)
- AppHeader + AppSidebar + Main Content 조합
- 전체 페이지 레이아웃 구조

## 🔄 새 컴포넌트 vs 기존 확장 결정 가이드

### ✅ 기존 컴포넌트 확장하는 경우

#### 1. 새로운 variant 추가
```typescript
// Button에 'success' variant 추가하고 싶다면
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger' | 'success'; // ✅ 확장
}
```

#### 2. 새로운 size 추가
```typescript
// Input에 'xs' size 추가하고 싶다면
interface InputProps {
  size?: 'xs' | 'sm' | 'md' | 'lg'; // ✅ 확장
}
```

#### 3. 기존 패턴과 80% 이상 유사한 경우
```typescript
// TextArea는 Input의 확장
interface TextAreaProps extends Omit<InputProps, 'type'> {
  rows?: number;
  maxLength?: number;
}
```

### 🆕 새로운 컴포넌트 만드는 경우

#### 1. 완전히 다른 UI 패턴
```typescript
// Modal, Dropdown, Carousel 등
// 기존 컴포넌트와 전혀 다른 UX
```

#### 2. 복합 컴포넌트
```typescript
// UserCard, ProductCard 등
// 여러 기본 컴포넌트를 조합한 복합 컴포넌트
```

#### 3. 특수한 비즈니스 로직
```typescript
// PaymentForm, SearchBox 등
// 도메인 특화 기능이 강한 컴포넌트
```

## 🎨 공통 Props 패턴

### 기본 Props (모든 컴포넌트 공통)
```typescript
interface BaseComponentProps {
  className?: string;
  testId?: string;
  children?: ReactNode;
}
```

### Size Props (크기 조절 가능한 컴포넌트)
```typescript
type Size = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
```

### Variant Props (스타일 변형 가능한 컴포넌트)
```typescript
type Variant = 'primary' | 'secondary' | 'danger' | 'success' | 'warning';
```

### State Props (상태 표시 컴포넌트)
```typescript
interface StateProps {
  loading?: boolean;
  disabled?: boolean;
  error?: boolean;
}
```

## 🔗 Atomic Design 컴포넌트 조합 패턴

### 1. Atoms 조합으로 Molecules 생성
```typescript
// ✅ atoms 조합 활용
const SearchBox = ({ onSearch, placeholder }: SearchBoxProps) => (
  <div className={styles.searchBox}>
    <Input 
      placeholder={placeholder}
      startIcon={<SearchIcon />}
      onChange={(e) => onSearch(e.target.value)}
    />
    <Button variant="primary" size="sm">
      검색
    </Button>
  </div>
);
```

### 2. Molecules 조합으로 Organisms 생성
```typescript
// ✅ molecules 조합 활용
const UserProfileCard = ({ user, onUpdate }: UserProfileCardProps) => (
  <div className={styles.card}>
    <div className={styles.header}>
      <UserAvatar src={user.avatar} alt={user.name} />
      <UserInfo name={user.name} email={user.email} />
    </div>
    <ProfileForm user={user} onSubmit={onUpdate} />
    <UserActions onEdit={handleEdit} onDelete={handleDelete} />
  </div>
);
```

### 3. Organisms 조합으로 Templates 생성
```typescript
// ✅ organisms 조합 활용
const DashboardLayout = ({ children }: DashboardLayoutProps) => (
  <div className={styles.dashboard}>
    <AppHeader onMenuToggle={handleMenuToggle} />
    <div className={styles.content}>
      <AppSidebar />
      <main className={styles.main}>
        {children}
      </main>
    </div>
  </div>
);
```

## 📝 컴포넌트 네이밍 가이드

### 1. Atoms (기본 컴포넌트)
```typescript
// ✅ 일반적인 이름 사용
Button, Input, Icon, Logo, Badge, Avatar
```

### 2. Molecules (atoms 조합)
```typescript
// ✅ 기능 + 컴포넌트 타입
AuthActions, UserDropdown, SearchBox, FormField
```

### 3. Organisms (molecules 조합)
```typescript
// ✅ 도메인 + 컴포넌트 타입
AppHeader, AppSidebar, UserProfileCard, ProductCard
```

### 4. Templates (페이지 레이아웃)
```typescript
// ✅ 레이아웃 + Layout
MainLayout, DashboardLayout, AuthLayout
```

## 🔍 컴포넌트 선택 결정 트리

### 질문 1: "어떤 기능이 필요한가?"

#### 버튼이 필요하다면?
1. **기본 액션** → `Button` (variant 선택)
2. **링크 역할** → `Button variant="ghost"` 또는 `Link`
3. **아이콘만** → `IconButton`

#### 입력 필드가 필요하다면?
1. **텍스트 입력** → `Input`
2. **여러 줄 입력** → `Input` 확장해서 `TextArea` 생성
3. **선택 입력** → `Input` 패턴 따라 `Select` 생성

#### 레이아웃이 필요하다면?
1. **컨테이너** → `Layout/Container`
2. **그리드 배치** → `Layout/Grid`
3. **플렉스 배치** → `Layout/Flex`
4. **페이지 전체** → `MainLayout`

### 질문 2: "비슷한 컴포넌트가 있는가?"

#### 있다면:
1. 기존 컴포넌트의 props 확장 검토
2. variant나 size 추가로 해결 가능한지 확인
3. 새로운 props 추가로 해결 가능한지 확인

#### 없다면:
1. 여러 기존 컴포넌트 조합으로 해결 가능한지 확인
2. 정말 새로운 컴포넌트가 필요한지 재검토
3. 적절한 Atomic Design 레이어에 배치

## 📋 컴포넌트 개발 체크리스트

### 개발 전 확인
- [ ] 기존 컴포넌트로 해결 가능한가?
- [ ] 기존 컴포넌트 확장으로 해결 가능한가?
- [ ] 여러 컴포넌트 조합으로 해결 가능한가?
- [ ] 정말 새로운 컴포넌트가 필요한가?
- [ ] 올바른 Atomic Design 레이어에 배치할 것인가?

### 개발 중 확인
- [ ] 기존 Props 패턴을 따르고 있는가?
- [ ] 네이밍이 일관성 있는가?
- [ ] 재사용 가능하게 설계되었는가?
- [ ] 적절한 Atomic Design 레이어에 배치되었는가?
- [ ] 의존성 방향이 올바른가?

### 개발 후 확인
- [ ] 다른 곳에서도 사용할 수 있는가?
- [ ] 기존 디자인 시스템과 일관성이 있는가?
- [ ] 접근성이 고려되었는가?
- [ ] 성능에 문제가 없는가?

## 💡 효율적인 컴포넌트 활용 팁

1. **먼저 찾기**: 새로 만들기 전에 기존 컴포넌트 인벤토리 확인
2. **조합 우선**: 단일 컴포넌트보다 기존 컴포넌트 조합 고려
3. **점진적 확장**: 한 번에 많은 기능보다 단계적 확장
4. **일관성 유지**: 기존 패턴과 네이밍 컨벤션 준수
5. **문서화**: 새로운 컴포넌트는 사용 예시와 함께 문서화
6. **Atomic Design 원칙**: 각 레이어의 역할과 책임 명확히 구분

## 🔧 ESLint 기반 Atomic Design 컴포넌트 개발 룰

### 📝 컴포넌트 파일 구조 규칙

#### 1. **파일 네이밍 컨벤션**
```typescript
// ✅ 올바른 파일명
Button.tsx, Button.module.scss
UserCard.tsx, UserCard.module.scss  
LoginForm.tsx, LoginForm.module.scss

// ❌ 잘못된 파일명
button.tsx, usercard.tsx
login-form.tsx, Login_Form.tsx
```

#### 2. **컴포넌트 Export 패턴**
```typescript
// ✅ Named export 사용 (필수)
export const Button: React.FC<ButtonProps> = ({ children, ...props }) => {
  return <button {...props}>{children}</button>;
};

// ❌ Default export 금지
export default Button;
```

#### 3. **Props 타입 정의**
```typescript
// ✅ 인터페이스로 Props 정의 (필수)
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
  children: ReactNode;
  onClick?: () => void;
}

// ❌ Type alias 사용 금지
type ButtonProps = {
  // ...
};
```

### 🎨 스타일링 ESLint 룰

#### 1. **CSS Modules 사용 강제**
```typescript
// ✅ CSS Modules import 필수
import styles from './Button.module.scss';

export const Button = () => (
  <button className={styles.button}>
    Click me
  </button>
);

// ❌ 인라인 스타일 금지
export const Button = () => (
  <button style={{ color: 'red' }}>
    Click me
  </button>
);
```

#### 2. **className 조합 패턴**
```typescript
// ✅ clsx 또는 조건부 클래스 사용
import styles from './Button.module.scss';

export const Button = ({ variant, disabled }: ButtonProps) => (
  <button 
    className={`${styles.button} ${styles[variant]} ${disabled ? styles.disabled : ''}`}
  >
    Click me
  </button>
);

// ✅ 또는 clsx 사용 (권장)
import clsx from 'clsx';
import styles from './Button.module.scss';

export const Button = ({ variant, disabled }: ButtonProps) => (
  <button 
    className={clsx(styles.button, styles[variant], {
      [styles.disabled]: disabled
    })}
  >
    Click me
  </button>
);
```

### ♿ 접근성 ESLint 룰

#### 1. **필수 접근성 속성**
```typescript
// ✅ 접근성 속성 포함 필수
export const Button = ({ children, loading, ...props }: ButtonProps) => (
  <button 
    {...props}
    aria-disabled={loading}
    aria-label={loading ? '로딩 중...' : undefined}
  >
    {children}
  </button>
);

// ✅ 이미지에 alt 속성 필수
export const Avatar = ({ src, name }: AvatarProps) => (
  <img src={src} alt={`${name}의 프로필 이미지`} />
);
```

#### 2. **키보드 내비게이션 지원**
```typescript
// ✅ 키보드 이벤트 핸들러 포함
export const Modal = ({ onClose }: ModalProps) => {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };
    
    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [onClose]);

  return (
    <div role="dialog" aria-modal="true">
      {/* Modal content */}
    </div>
  );
};
```

### ⚡ 성능 ESLint 룰

#### 1. **불필요한 리렌더링 방지**
```typescript
// ✅ React.memo 사용 (필요한 경우)
export const ExpensiveComponent = React.memo<ExpensiveComponentProps>(
  ({ data, onUpdate }) => {
    return (
      <div>
        {/* 복잡한 렌더링 로직 */}
      </div>
    );
  }
);

// ✅ useCallback 사용 (필요한 경우)
export const ParentComponent = () => {
  const [items, setItems] = useState([]);
  
  const handleItemClick = useCallback((id: string) => {
    setItems(prev => prev.filter(item => item.id !== id));
  }, []);

  return (
    <div>
      {items.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onClick={handleItemClick}
        />
      ))}
    </div>
  );
};
```

#### 2. **Props 구조분해 패턴**
```typescript
// ✅ Props 구조분해 사용
export const Button = ({ 
  variant = 'primary', 
  size = 'md', 
  loading = false,
  children,
  ...restProps 
}: ButtonProps) => {
  return (
    <button 
      className={clsx(styles.button, styles[variant], styles[size])}
      disabled={loading}
      {...restProps}
    >
      {loading ? <Spinner /> : children}
    </button>
  );
};

// ❌ props 객체 직접 사용 금지
export const Button = (props: ButtonProps) => {
  return (
    <button className={styles.button}>
      {props.children}
    </button>
  );
};
```

### 🏗️ 컴포넌트 구조 ESLint 룰

#### 1. **컴포넌트 크기 제한**
```typescript
// ✅ 50줄 이하 권장 (ESLint: max-lines-per-function)
export const Button = ({ variant, children }: ButtonProps) => {
  return (
    <button className={clsx(styles.button, styles[variant])}>
      {children}
    </button>
  );
};

// ❌ 너무 긴 컴포넌트는 분리 필요
export const VeryLongComponent = () => {
  // 100줄 이상의 복잡한 로직
  // → 여러 컴포넌트로 분리 필요
};
```

#### 2. **Hook 사용 순서**
```typescript
// ✅ Hook 사용 순서 준수
export const Component = () => {
  // 1. useState
  const [state, setState] = useState(initial);
  
  // 2. useEffect
  useEffect(() => {
    // effect logic
  }, []);
  
  // 3. Custom hooks
  const { data, loading } = useCustomHook();
  
  // 4. Event handlers
  const handleClick = () => {
    setState(newValue);
  };
  
  // 5. Render
  return <div onClick={handleClick}>{data}</div>;
};
```

### 📦 Import/Export ESLint 룰

#### 1. **Import 순서**
```typescript
// ✅ Import 순서 준수
// 1. React 및 외부 라이브러리
import React, { useState, useEffect } from 'react';
import clsx from 'clsx';

// 2. Atoms (가장 기본)
import { Button, Input, Icon } from '@/components/atoms';

// 3. Molecules (atoms 조합)
import { AuthActions, UserDropdown } from '@/components/molecules';

// 4. Organisms (molecules 조합)
import { AppHeader } from '@/components/organisms';

// 5. Templates (organisms 조합)
import { MainLayout } from '@/components/templates';

// 6. 스타일 및 타입
import styles from './Component.module.scss';
import type { ComponentProps } from './types';
```

#### 2. **절대 경로 사용 강제**
```typescript
// ✅ 절대 경로 사용 (필수)
import { Button } from '@/components/atoms/Button';
import { useAuth } from '@/hooks/useAuth';

// ❌ 상대 경로 금지
import { Button } from '../../../components/atoms/Button';
import { useAuth } from '../../../hooks/useAuth';
```

이러한 ESLint 룰을 통해 일관성 있고 품질 높은 Atomic Design UI 컴포넌트를 개발할 수 있습니다.
import { useAuth } from '../../../shared/hooks/useAuth';
```

이러한 ESLint 룰을 통해 일관성 있고 품질 높은 UI 컴포넌트를 개발할 수 있습니다.