# Performance Rules

## 번들 최적화

### 코드 스플리팅
```typescript
// 라우트 기반 코드 스플리팅
import { lazy, Suspense } from 'react';

const HomePage = lazy(() => import('@/pages/HomePage/HomePage'));
const AboutPage = lazy(() => import('@/pages/AboutPage/AboutPage'));

export const AppRouter = () => (
  <Router>
    <Suspense fallback={<div>로딩 중...</div>}>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
      </Routes>
    </Suspense>
  </Router>
);
```

### Vite 번들 설정
```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom'],
          ui: ['react-bootstrap', 'bootstrap'],
          query: ['@tanstack/react-query'],
          supabase: ['@supabase/supabase-js'],
        },
      },
    },
    chunkSizeWarningLimit: 1000,
  },
  css: {
    codeSplit: true,
  },
});
```

## React 메모이제이션

### React.memo 사용 기준
```typescript
// ✅ 권장: 복잡한 렌더링 컴포넌트
export const ExpensiveListItem = React.memo<ListItemProps>(({
  item,
  onUpdate,
  isSelected
}) => {
  return (
    <div className={isSelected ? 'selected' : ''}>
      {/* 복잡한 렌더링 로직 */}
    </div>
  );
});

// ❌ 비권장: 단순한 컴포넌트
const SimpleButton = React.memo(({ children, onClick }) => (
  <button onClick={onClick}>{children}</button>
));
```

### useMemo 패턴
```typescript
const TodoList: React.FC<TodoListProps> = ({ todos, filter, sortBy }) => {
  // ✅ 권장: 비용이 큰 계산 메모이제이션
  const filteredAndSortedTodos = useMemo(() => {
    return todos
      .filter(todo => {
        switch (filter) {
          case 'completed': return todo.completed;
          case 'active': return !todo.completed;
          default: return true;
        }
      })
      .sort((a, b) => {
        switch (sortBy) {
          case 'date': return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
          case 'title': return a.title.localeCompare(b.title);
          default: return 0;
        }
      });
  }, [todos, filter, sortBy]);

  return (
    <div>
      {filteredAndSortedTodos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </div>
  );
};
```

### useCallback 패턴
```typescript
const TodoApp: React.FC = () => {
  const [todos, setTodos] = useState<Todo[]>([]);

  // ✅ 권장: 자식 컴포넌트에 전달되는 함수
  const handleTodoToggle = useCallback((id: string) => {
    setTodos(prev => prev.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  }, []);

  const handleTodoDelete = useCallback((id: string) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []);

  return (
    <TodoList 
      todos={todos}
      onToggle={handleTodoToggle}
      onDelete={handleTodoDelete}
    />
  );
};
```

## 이미지 최적화

### 지연 로딩
```typescript
const OptimizedImage: React.FC<ImageProps> = ({
  src, alt, width, height, className
}) => {
  return (
    <img
      src={src}
      alt={alt}
      width={width}
      height={height}
      className={className}
      loading="lazy"
      decoding="async"
    />
  );
};
```

### 반응형 이미지
```typescript
const ResponsiveImage: React.FC = () => {
  return (
    <img
      src="/images/hero-1200.jpg"
      srcSet="
        /images/hero-400.jpg 400w,
        /images/hero-800.jpg 800w,
        /images/hero-1200.jpg 1200w
      "
      sizes="
        (max-width: 768px) 400px,
        (max-width: 1024px) 800px,
        1200px
      "
      alt="Hero Image"
      loading="lazy"
    />
  );
};
```

## 네트워크 최적화

### TanStack Query 최적화
```typescript
const useTodos = () => {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    staleTime: 5 * 60 * 1000,          // 5분간 fresh
    gcTime: 10 * 60 * 1000,            // 10분간 캐시 보관
    refetchOnWindowFocus: false,
  });
};

// 병렬 쿼리 최적화
const useUserDashboard = (userId: string) => {
  const userQuery = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  });

  const todosQuery = useQuery({
    queryKey: ['todos', userId],
    queryFn: () => fetchUserTodos(userId),
    enabled: !!userId,
  });

  return {
    user: userQuery.data,
    todos: todosQuery.data,
    isLoading: userQuery.isLoading || todosQuery.isLoading,
  };
};
```

## 무한 스크롤

### TanStack Query 무한 스크롤
```typescript
const useTodosInfinite = (filter: string) => {
  return useInfiniteQuery({
    queryKey: ['todos', 'infinite', filter],
    queryFn: ({ pageParam = 0 }) => 
      fetchTodos({ page: pageParam, filter, limit: 20 }),
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.hasMore ? allPages.length : undefined;
    },
    staleTime: 5 * 60 * 1000,
  });
};

const InfiniteTodoList: React.FC = () => {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useTodosInfinite('all');

  const { ref } = useInView({
    threshold: 0.1,
    onChange: (inView) => {
      if (inView && hasNextPage && !isFetchingNextPage) {
        fetchNextPage();
      }
    },
  });

  return (
    <div>
      {data?.pages.map((page, pageIndex) => (
        <div key={pageIndex}>
          {page.todos.map(todo => (
            <TodoItem key={todo.id} todo={todo} />
          ))}
        </div>
      ))}
      <div ref={ref}>
        {isFetchingNextPage && <div>더 로딩 중...</div>}
      </div>
    </div>
  );
};
```

## CSS 최적화

### 효율적인 스타일링
```scss
// ✅ 권장: 효율적인 선택자
.todo-item {
  display: flex;
  align-items: center;
}

// ❌ 비권장: 깊은 중첩
.page .content .section .article .todo-item { }

// ✅ 권장: 단일 속성 트랜지션
.card {
  transition: transform 0.2s ease;
}

// ❌ 비권장: 모든 속성 트랜지션
.card {
  transition: all 0.2s ease;
}
```

## 성능 측정

### Web Vitals
```typescript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

export const measureWebVitals = () => {
  getCLS(console.log);  // Cumulative Layout Shift
  getFID(console.log);  // First Input Delay
  getFCP(console.log);  // First Contentful Paint
  getLCP(console.log);  // Largest Contentful Paint
  getTTFB(console.log); // Time to First Byte
};

// main.tsx에서 측정
if (process.env.NODE_ENV === 'production') {
  measureWebVitals();
}
```

### React Profiler
```typescript
import { Profiler } from 'react';

const onRenderCallback = (
  id: string,
  phase: 'mount' | 'update',
  actualDuration: number
) => {
  console.log('Profiler:', { id, phase, actualDuration });
};

export const ProfiledComponent: React.FC = ({ children }) => (
  <Profiler id="TodoApp" onRender={onRenderCallback}>
    {children}
  </Profiler>
);
```

## Tree Shaking 최적화

### 올바른 Import
```typescript
// ✅ 권장: 명시적 import
import { debounce } from 'lodash';
import { format } from 'date-fns';

// ❌ 비권장: 전체 라이브러리 import
import _ from 'lodash';
import * as dateFns from 'date-fns';
```

### 환경별 최적화
```typescript
// 개발환경에서만 로드
if (process.env.NODE_ENV === 'development') {
  import('@/lib/dev-tools').then(module => {
    module.initDevTools();
  });
}

// 프로덕션에서만 로드
if (process.env.NODE_ENV === 'production') {
  import('@/lib/analytics').then(module => {
    module.initAnalytics();
  });
}
```

## 메모리 관리

### 이벤트 리스너 정리
```typescript
const useWindowResize = () => {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener('resize', handleResize);
    
    // ✅ 중요: 정리 함수
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return windowSize;
};
```

### 메모리 누수 방지
```typescript
const useApiPolling = (url: string, interval: number) => {
  const [data, setData] = useState(null);

  useEffect(() => {
    let isMounted = true;

    const fetchData = async () => {
      try {
        const response = await fetch(url);
        const result = await response.json();
        
        if (isMounted) {
          setData(result);
        }
      } catch (error) {
        if (isMounted) {
          console.error('Fetch error:', error);
        }
      }
    };

    const intervalId = setInterval(fetchData, interval);

    return () => {
      isMounted = false;
      clearInterval(intervalId);
    };
  }, [url, interval]);

  return data;
};
```