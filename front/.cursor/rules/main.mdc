
# Vibe 프로젝트 Atomic Design 개발 가이드

> 기존 Atomic Design 아키텍처를 유지하며 새로운 기능을 추가하고 코드를 일관성 있게 유지보수하기 위한 가이드

## 🏗️ 현재 프로젝트 구조 (Atomic Design + FSD)

```
front/src/
├── app/           # 앱 초기화, 전역 설정, 라우팅
├── pages/         # 페이지 컴포넌트 (라우트 레벨)
├── components/    # Atomic Design 컴포넌트
│   ├── atoms/     # 기본 UI 요소 (Button, Input, Icon 등)
│   ├── molecules/ # atoms 조합 (AuthActions, UserDropdown 등)
│   ├── organisms/ # molecules 조합 (AppHeader, AppSidebar 등)
│   └── templates/ # 페이지 레이아웃 (MainLayout 등)
├── hooks/         # 커스텀 훅
├── shared/        # 공유 코드 (API, Types, Utils)
└── styles/        # 전역 스타일, 변수, 믹스인
```

## 🧩 새 컴포넌트 추가 시 Atomic Design 레이어 선택 가이드

### 질문 기반 레이어 결정

**1️⃣ 이 컴포넌트가 어디에 속하는가?**

#### Atoms (기본 UI 요소)
- 🔧 **가장 기본적인 UI 요소** → `components/atoms`
- 🎨 **스타일링만 있고 비즈니스 로직 없음** → `components/atoms`
- 🔄 **여러 곳에서 재사용되는 기본 요소** → `components/atoms`

**예시**: Button, Input, Icon, Logo, Badge, Avatar

#### Molecules (atoms 조합)
- 🔗 **2-3개의 atoms를 조합** → `components/molecules`
- ⚡ **단순한 비즈니스 로직 포함** → `components/molecules`
- 🎯 **특정 기능을 위한 조합** → `components/molecules`

**예시**: AuthActions, UserDropdown, SearchBox, FormField

#### Organisms (molecules 조합)
- 🧩 **여러 molecules를 조합** → `components/organisms`
- 🏢 **복잡한 비즈니스 로직 포함** → `components/organisms`
- 📦 **독립적인 기능 블록** → `components/organisms`

**예시**: AppHeader, AppSidebar, ProductCard, UserProfile

#### Templates (페이지 레이아웃)
- 📄 **페이지 전체 구조** → `components/templates`
- 🏗️ **organisms 배치 및 레이아웃** → `components/templates`
- 🎨 **스타일링과 구조만, 데이터 없음** → `components/templates`

**예시**: MainLayout, DashboardLayout, AuthLayout

### 2️⃣ 의존성 확인 (Atomic Design 규칙)
```
pages → templates → organisms → molecules → atoms
```
- 하위 레이어는 상위 레이어를 참조할 수 없음
- 동일 레이어 간 참조 금지
- atoms는 다른 atoms만 참조 가능
- molecules는 atoms와 다른 molecules만 참조 가능

## 📂 필수 파일 구조 템플릿

### 모든 컴포넌트는 동일한 구조를 유지

```
ComponentName/
├── index.ts                 # 🔗 Public API (필수)
├── ComponentName.tsx        # ⚛️ 컴포넌트 로직 (필수)
├── ComponentName.module.scss # 🎨 스타일 (필수)
└── types.ts                 # 📝 타입 정의 (선택적)
```

**✅ 올바른 예시:**
```typescript
// index.ts
export { UserCard } from './UserCard';
export type { UserCardProps } from './UserCard';

// UserCard.tsx
import styles from './UserCard.module.scss';

interface UserCardProps {
  user: User;
  onClick?: () => void;
}

export const UserCard: React.FC<UserCardProps> = ({ user, onClick }) => {
  return (
    <div className={styles.root} onClick={onClick}>
      <h3 className={styles.name}>{user.name}</h3>
      <p className={styles.email}>{user.email}</p>
    </div>
  );
};
```

## 🎨 스타일링 일관성 유지

### 기존 디자인 시스템 활용

```scss
// 모든 .module.scss 파일에서 필수 import
@use '@/shared/styles/variables' as *;
@use '@/shared/styles/mixins' as *;

.root {
  // 기존 CSS 변수 활용
  padding: var(--spacing-4);
  background: var(--color-white);
  border-radius: var(--border-radius);
  
  // 기존 믹스인 활용
  @include card;
  @include mobile {
    padding: var(--spacing-3);
  }
}
```

### 새로운 스타일 추가 시 우선순위

1. **기존 CSS 변수** 재사용 시도
2. **기존 믹스인** 재사용 시도  
3. 새로운 것이 필요하면 `styles/` 폴더에 추가

## 🔗 Import 규칙 준수

### Path Alias 사용 필수

```typescript
// ✅ 올바른 import
import { Button } from '@/components/atoms/Button';
import { AuthActions } from '@/components/molecules/AuthActions';
import { AppHeader } from '@/components/organisms/AppHeader';
import { MainLayout } from '@/components/templates/MainLayout';

// ❌ 잘못된 import (상대 경로)
import { Button } from '../../../components/atoms/Button';
```

### Atomic Design 레이어 순서 맞춰 import

```typescript
// 1. React 및 라이브러리
import { useState } from 'react';
import { Link } from 'react-router-dom';

// 2. Atoms (가장 기본)
import { Button, Input, Icon } from '@/components/atoms';

// 3. Molecules (atoms 조합)
import { AuthActions, UserDropdown } from '@/components/molecules';

// 4. Organisms (molecules 조합)
import { AppHeader } from '@/components/organisms';

// 5. Templates (organisms 조합)
import { MainLayout } from '@/components/templates';

// 6. 현재 레이어
import styles from './ComponentName.module.scss';
```

## 🧪 기존 컴포넌트 수정 시 가이드

### 수정 전 확인사항

1. **Props 인터페이스 변경** → 모든 사용처 확인
2. **CSS 클래스명 변경** → 다른 컴포넌트 영향도 확인
3. **export 변경** → import하는 모든 파일 확인
4. **Atomic Design 레이어 변경** → 의존성 방향 확인

### Breaking Change 최소화

```typescript
// ✅ 좋은 방법: 기존 props 유지하며 새 props 추가
interface ButtonProps {
  children: ReactNode;
  variant?: 'primary' | 'secondary' | 'danger'; // 기존
  size?: 'sm' | 'md' | 'lg' | 'xl'; // 새로 추가 (xl만 추가)
  // 새 기능
  loading?: boolean;
}

// ❌ 나쁜 방법: 기존 props 타입 변경
interface ButtonProps {
  children: ReactNode;
  variant?: 'solid' | 'outline'; // 기존 값들이 변경됨
}
```

## 🚀 새 기능 추가 워크플로우

### 1. 기능 분석 및 Atomic Design 레이어 결정
```
🤔 "사용자 프로필 편집 기능"을 추가한다면?

1. atoms → UserAvatar, EditIcon (기본 UI 요소)
2. molecules → ProfileForm, EditButton (atoms 조합)
3. organisms → UserProfileCard (molecules 조합)
4. templates → ProfileLayout (organisms 배치)
```

### 2. Hook 아키텍처 결정
```
🤔 "프로필 편집 기능"에 필요한 Hook은?

1. useUserProfile (Core) → 사용자 데이터 관리 (Router 독립)
2. useUserProfileActions (Action) → 수정 + 리다이렉트 (Router 의존)

💡 Router 컨텍스트 필요 여부로 Core/Action 분리 결정
```

### 3. 타입 정의 (타입 우선 개발)
```typescript
// shared/types/user.ts에 추가
export interface UserUpdateDto {
  name?: string;
  email?: string;
  avatar?: File;
}
```

### 4. Atomic Design 컴포넌트 구현

#### Atoms 생성
```typescript
// components/atoms/UserAvatar/UserAvatar.tsx
interface UserAvatarProps {
  src?: string;
  alt: string;
  size?: 'sm' | 'md' | 'lg';
}

export const UserAvatar: React.FC<UserAvatarProps> = ({ src, alt, size = 'md' }) => {
  return (
    <img 
      src={src || '/default-avatar.png'} 
      alt={alt}
      className={styles.avatar}
    />
  );
};
```

#### Molecules 생성
```typescript
// components/molecules/ProfileForm/ProfileForm.tsx
import { Input, Button } from '@/components/atoms';

interface ProfileFormProps {
  user: User;
  onSubmit: (data: UserUpdateDto) => void;
  isLoading?: boolean;
}

export const ProfileForm: React.FC<ProfileFormProps> = ({ user, onSubmit, isLoading }) => {
  return (
    <form onSubmit={handleSubmit}>
      <Input label="이름" defaultValue={user.name} />
      <Input label="이메일" defaultValue={user.email} />
      <Button type="submit" loading={isLoading}>저장</Button>
    </form>
  );
};
```

#### Organisms 생성
```typescript
// components/organisms/UserProfileCard/UserProfileCard.tsx
import { UserAvatar } from '@/components/atoms';
import { ProfileForm } from '@/components/molecules';

interface UserProfileCardProps {
  user: User;
  onUpdate: (data: UserUpdateDto) => void;
}

export const UserProfileCard: React.FC<UserProfileCardProps> = ({ user, onUpdate }) => {
  return (
    <div className={styles.card}>
      <UserAvatar src={user.avatar} alt={user.name} size="lg" />
      <ProfileForm user={user} onSubmit={onUpdate} />
    </div>
  );
};
```

### 5. Hook 구현 (Core + Action 패턴)
```typescript
// hooks/useUserProfile.ts (Core Hook)
export const useUserProfile = (userId: string) => {
  const query = useQuery(['user', userId], () => fetchUser(userId));
  const updateMutation = useMutation(updateUser);
  
  return {
    user: query.data,
    isLoading: query.isLoading,
    updateProfile: updateMutation.mutate,
    updateProfileAsync: updateMutation.mutateAsync, // await 가능
  };
};

// hooks/useUserProfileActions.ts (Action Hook)  
export const useUserProfileActions = (userId: string) => {
  const navigate = useNavigate();
  const profile = useUserProfile(userId);
  
  const updateWithRedirect = async (data: UserUpdateDto, redirectTo = '/profile') => {
    await profile.updateProfileAsync(data);
    navigate(redirectTo, { replace: true });
  };
  
  return { ...profile, updateWithRedirect };
};
```

### 6. 기존 코드와의 통합
```typescript
// pages/ProfilePage에서 활용
import { UserProfileCard } from '@/components/organisms/UserProfileCard';
import { useUserProfileActions } from '@/hooks/useUserProfileActions';

export const ProfilePage = () => {
  const { user, updateWithRedirect, isLoading } = useUserProfileActions(userId);
  
  return (
    <MainLayout>
      <UserProfileCard 
        user={user} 
        onUpdate={updateWithRedirect}
      />
    </MainLayout>
  );
};
```

## 📋 코드 리뷰 체크리스트

### Atomic Design 구조 검증
- [ ] 올바른 Atomic Design 레이어에 배치되었는가?
- [ ] 의존성 방향이 올바른가? (하위→상위만 허용)
- [ ] atoms는 다른 atoms만 참조하는가?
- [ ] molecules는 atoms와 molecules만 참조하는가?
- [ ] organisms는 molecules와 organisms만 참조하는가?

### Hook 아키텍처 검증
- [ ] Router 컨텍스트 의존성이 올바르게 분리되었는가?
- [ ] Core Hook과 Action Hook이 적절히 분리되었는가?
- [ ] 상태 관리 도구 선택이 적절한가? (TanStack Query vs Zustand vs React State)
- [ ] AuthInitializer에서 사용되는 Hook이 Router 독립적인가?

### 코드 품질
- [ ] TypeScript 타입이 명시적으로 정의되었는가?
- [ ] Props 인터페이스가 명확한가?
- [ ] CSS 변수와 믹스인을 활용했는가?
- [ ] Import 순서가 올바른가?

### 재사용성
- [ ] 비슷한 기능의 기존 컴포넌트는 없는가?
- [ ] 컴포넌트가 과도하게 특수화되지 않았는가?
- [ ] Props가 유연하게 설계되었는가?

### 성능
- [ ] 불필요한 리렌더링이 없는가?
- [ ] 큰 객체를 props로 전달하지 않는가?
- [ ] 무거운 계산에 useMemo를 적용했는가?

## 🔄 리팩토링 가이드

### 컴포넌트 분리 기준
```typescript
// ❌ 너무 큰 컴포넌트
const UserDashboard = () => {
  // 사용자 정보 로직 (50줄)
  // 통계 차트 로직 (30줄)  
  // 최근 활동 로직 (40줄)
  return (/* 복잡한 JSX */);
};

// ✅ Atomic Design에 맞게 분리된 컴포넌트
const UserDashboard = () => {
  return (
    <MainLayout>
      <UserProfileCard user={user} />
      <StatsChart data={stats} />
      <RecentActivity activities={activities} />
    </MainLayout>
  );
};
```

### Atomic Design 레이어 이동
```typescript
// ❌ 잘못된 레이어 배치
// molecules/UserCard.tsx에서 복잡한 비즈니스 로직 포함

// ✅ 올바른 레이어 배치
// atoms/UserAvatar.tsx - 기본 아바타 컴포넌트
// molecules/UserInfo.tsx - 아바타 + 이름 + 이메일 조합
// organisms/UserCard.tsx - UserInfo + 액션 버튼들 조합
```

## 💡 일관성 유지 팁

1. **기존 컴포넌트 참고**: 비슷한 기능의 기존 컴포넌트를 먼저 찾아보기
2. **CSS 변수 활용**: 하드코딩된 값 대신 CSS 변수 사용
3. **타입 재사용**: 비슷한 타입이 있다면 확장해서 사용
4. **네이밍 일관성**: 기존 파일들의 네이밍 패턴 따르기
5. **작은 단위로 커밋**: 기능별로 작게 나누어 커밋하기
6. **Atomic Design 원칙 준수**: 각 레이어의 역할과 책임 명확히 구분

이 가이드를 따라 기존 Vibe 프로젝트의 Atomic Design 아키텍처를 유지하며 새로운 기능을 안전하게 추가할 수 있습니다.
3. **타입 재사용**: 비슷한 타입이 있다면 확장해서 사용
4. **네이밍 일관성**: 기존 파일들의 네이밍 패턴 따르기
5. **작은 단위로 커밋**: 기능별로 작게 나누어 커밋하기

이 가이드를 따라 기존 Vibe 프로젝트의 일관성을 유지하며 새로운 기능을 안전하게 추가할 수 있습니다.