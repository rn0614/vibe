# Vibe 프로젝트 개발 가이드

> 현재 프로젝트 구조에 기반한 일관성 있는 개발을 위한 종합 가이드

## 🏗️ 현재 프로젝트 구조

```
front/src/
├── app/                    # 🏗️ 애플리케이션 설정 및 초기화
│   ├── providers/         # Context Providers (Auth, Query)
│   ├── routers/          # 라우팅 설정 및 구성
│   ├── store/            # 전역 상태 관리
│   ├── styles/           # 전역 스타일 (variables, mixins, global)
│   └── App.tsx           # 메인 앱 컴포넌트
├── components/             # 🧩 UI 컴포넌트 (Atomic Design)
│   ├── atoms/            # 기본 UI 요소 (Button, Input, Logo 등)
│   ├── molecules/        # atoms 조합 (AuthActions, UserDropdown 등)
│   ├── organisms/        # molecules 조합 (AppHeader, AppSidebar 등)
│   └── templates/        # 페이지 레이아웃 (MainLayout 등)
├── domains/               # 🏢 도메인별 비즈니스 로직
│   ├── auth/            # 인증 도메인 (로그인, 사용자 관리)
│   ├── supabaseCommon/  # Supabase 공통 로직
│   └── theme/           # 테마 관리 도메인
├── pages/                 # 📄 페이지 컴포넌트 (라우트 레벨)
│   ├── HomePage/
│   ├── AboutPage/
│   ├── LoginPage/
│   └── TodoPage/
└── shared/               # 🔧 공유 코드 (프로젝트 전체에서 재사용)
    ├── api/             # API 클라이언트 및 설정
    ├── constants/       # 상수 정의
    ├── lib/            # 외부 라이브러리 설정
    └── types/          # TypeScript 타입 정의
```

## 📂 레이어별 역할과 책임

### 🏗️ App Layer
**역할**: 애플리케이션의 전역 설정과 초기화

- **providers/**: React Context 제공자들
  - `auth/`: 인증 상태 초기화
  - `query/`: TanStack Query 설정
- **routers/**: 애플리케이션 라우팅
  - `AppRouter.tsx`: 라우터 컴포넌트
  - `routes.tsx`: 라우트 정의
- **store/**: 전역 상태 관리 (Zustand)
- **styles/**: 전역 스타일 시스템
  - `_variables.scss`: CSS 변수
  - `_mixins.scss`: SCSS 믹스인
  - `global.scss`: 전역 스타일

### 🧩 Components Layer (Atomic Design)
**역할**: 재사용 가능한 UI 컴포넌트 구성

#### Atoms (기본 UI 요소)
- **특징**: 가장 기본적인 UI 요소, 독립적으로 사용 가능
- **예시**: `Button`, `Input`, `Logo`, `Icon`
- **의존성**: 다른 컴포넌트에 의존하지 않음

#### Molecules (atoms 조합)
- **특징**: 2-3개의 atoms를 조합한 단순한 컴포넌트
- **예시**: `AuthActions`, `UserDropdown`, `NavigationItem`
- **의존성**: atoms만 참조 가능

#### Organisms (molecules 조합)
- **특징**: 복잡한 UI 블록, 독립적인 기능 단위
- **예시**: `AppHeader`, `AppSidebar`, `AuthUI`
- **의존성**: atoms, molecules 참조 가능

#### Templates (페이지 레이아웃)
- **특징**: 페이지 전체 구조와 레이아웃
- **예시**: `MainLayout`
- **의존성**: atoms, molecules, organisms 참조 가능

### 🏢 Domains Layer
**역할**: 도메인별 비즈니스 로직과 상태 관리

- **auth/**: 인증 관련 로직
  - `hooks/useAuth.ts`: 인증 상태 관리
  - `hooks/useAuthActions.ts`: 인증 액션들
- **supabaseCommon/**: Supabase 공통 로직
  - `hooks/useSupabaseQuery.ts`: Supabase 쿼리 훅
- **theme/**: 테마 관리
  - `hooks/useTheme.ts`: 테마 상태 관리

### 📄 Pages Layer
**역할**: 라우트와 1:1 매핑되는 페이지 컴포넌트

- URL 경로와 직접 연결
- 도메인 로직과 UI 컴포넌트를 조합
- 페이지별 비즈니스 로직 포함

### 🔧 Shared Layer
**역할**: 프로젝트 전체에서 재사용되는 공통 코드

- **api/**: HTTP 클라이언트, Supabase 설정
- **constants/**: 애플리케이션 상수
- **lib/**: 외부 라이브러리 설정 및 유틸리티
- **types/**: TypeScript 타입 정의

## 🧪 새 기능 추가 워크플로우

### 1. 기능 분석 및 레이어 결정

```
🤔 "사용자 프로필 관리" 기능을 추가한다면?

1. domains/user/ 생성
   ├── hooks/useUserProfile.ts    # 사용자 프로필 상태 관리
   └── hooks/useUserActions.ts    # 사용자 관련 액션들

2. components/ 확장
   ├── atoms/UserAvatar/          # 사용자 아바타 컴포넌트
   ├── molecules/UserInfo/        # 사용자 정보 표시
   └── organisms/UserProfileCard/ # 프로필 카드

3. pages/ProfilePage/ 생성       # 프로필 페이지

4. shared/types/ 확장
   └── user.ts                    # 사용자 관련 타입
```

### 2. 도메인 로직 구현 (domains/)

```typescript
// domains/user/hooks/useUserProfile.ts
import { useQuery } from '@tanstack/react-query';
import { getUserProfile } from '@/shared/api';

export const useUserProfile = (userId: string) => {
  return useQuery({
    queryKey: ['user', 'profile', userId],
    queryFn: () => getUserProfile(userId),
    enabled: !!userId,
  });
};

// domains/user/hooks/useUserActions.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';
import { updateUserProfile } from '@/shared/api';

export const useUserActions = () => {
  const queryClient = useQueryClient();
  const navigate = useNavigate();

  const updateProfile = useMutation({
    mutationFn: updateUserProfile,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user'] });
    },
  });

  const updateProfileWithRedirect = async (data: UserUpdateDto) => {
    await updateProfile.mutateAsync(data);
    navigate('/profile', { replace: true });
  };

  return {
    updateProfile: updateProfile.mutate,
    updateProfileWithRedirect,
    isUpdating: updateProfile.isPending,
  };
};
```

### 3. UI 컴포넌트 구현 (components/)

```typescript
// components/atoms/UserAvatar/UserAvatar.tsx
import styles from './UserAvatar.module.scss';

interface UserAvatarProps {
  src?: string;
  alt: string;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export const UserAvatar: React.FC<UserAvatarProps> = ({ 
  src, 
  alt, 
  size = 'md',
  className 
}) => {
  return (
    <img 
      src={src || '/default-avatar.png'} 
      alt={alt}
      className={`${styles.avatar} ${styles[size]} ${className || ''}`}
    />
  );
};

// components/organisms/UserProfileCard/UserProfileCard.tsx
import { UserAvatar } from '@/components/atoms';
import { UserInfo } from '@/components/molecules';
import { useUserProfile, useUserActions } from '@/domains/user/hooks';

interface UserProfileCardProps {
  userId: string;
}

export const UserProfileCard: React.FC<UserProfileCardProps> = ({ userId }) => {
  const { data: user, isLoading } = useUserProfile(userId);
  const { updateProfileWithRedirect } = useUserActions();

  if (isLoading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div className={styles.card}>
      <UserAvatar src={user.avatar} alt={user.name} size="lg" />
      <UserInfo user={user} onUpdate={updateProfileWithRedirect} />
    </div>
  );
};
```

### 4. 페이지 구현 (pages/)

```typescript
// pages/ProfilePage/ProfilePage.tsx
import { MainLayout } from '@/components/templates';
import { UserProfileCard } from '@/components/organisms';
import { useParams } from 'react-router-dom';

export const ProfilePage: React.FC = () => {
  const { userId } = useParams<{ userId: string }>();

  if (!userId) return <div>Invalid user ID</div>;

  return (
    <MainLayout>
      <div className="container py-4">
        <h1>User Profile</h1>
        <UserProfileCard userId={userId} />
      </div>
    </MainLayout>
  );
};
```

## 📋 개발 규칙 및 가이드라인

### 컴포넌트 생성 규칙

#### 필수 파일 구조
```
ComponentName/
├── index.ts                     # 🔗 Public API (필수)
├── ComponentName.tsx            # ⚛️ 컴포넌트 로직 (필수)
├── ComponentName.module.scss    # 🎨 스타일 (필수)
└── types.ts                     # 📝 타입 정의 (선택)
```

#### 컴포넌트 템플릿
```typescript
// index.ts
export { ComponentName } from './ComponentName';
export type { ComponentNameProps } from './ComponentName';

// ComponentName.tsx
import { ReactNode } from 'react';
import styles from './ComponentName.module.scss';

interface ComponentNameProps {
  children?: ReactNode;
  className?: string;
  // 기타 props...
}

export const ComponentName: React.FC<ComponentNameProps> = ({ 
  children,
  className,
  ...rest 
}) => {
  return (
    <div className={`${styles.root} ${className || ''}`} {...rest}>
      {children}
    </div>
  );
};
```

### 스타일링 가이드라인

#### SCSS 모듈 템플릿
```scss
// ComponentName.module.scss
@use '@/app/styles/variables' as *;
@use '@/app/styles/mixins' as *;

.root {
  // CSS 변수 활용
  padding: var(--spacing-4);
  background: var(--color-white);
  border-radius: var(--border-radius);
  
  // 믹스인 활용
  @include card;
  
  @include mobile {
    padding: var(--spacing-3);
  }
}
```

### Import 순서 및 규칙

```typescript
// 1. React 및 외부 라이브러리
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';

// 2. Shared 레이어
import { api } from '@/shared/api';
import type { User } from '@/shared/types';

// 3. Domains 레이어
import { useAuth } from '@/domains/auth/hooks';
import { useTheme } from '@/domains/theme/hooks';

// 4. Components 레이어 (Atomic Design 순서)
import { Button, Input } from '@/components/atoms';
import { UserDropdown } from '@/components/molecules';
import { AppHeader } from '@/components/organisms';
import { MainLayout } from '@/components/templates';

// 5. 현재 컴포넌트 관련
import styles from './ComponentName.module.scss';
import type { ComponentNameProps } from './types';
```

### 도메인 훅 설계 패턴

#### Core Hook (도메인 로직)
```typescript
// domains/auth/hooks/useAuth.ts
export const useAuth = () => {
  // Router에 의존하지 않는 순수한 인증 로직
  const query = useQuery(['auth', 'user'], getCurrentUser);
  
  return {
    user: query.data,
    isAuthenticated: !!query.data,
    isLoading: query.isLoading,
    refetch: query.refetch,
  };
};
```

#### Action Hook (라우터 의존 로직)
```typescript
// domains/auth/hooks/useAuthActions.ts
export const useAuthActions = () => {
  const navigate = useNavigate();
  const auth = useAuth();
  
  const loginWithRedirect = async (credentials: LoginCredentials) => {
    await login(credentials);
    auth.refetch();
    navigate('/dashboard');
  };
  
  return {
    ...auth,
    loginWithRedirect,
    logout: () => {
      logout();
      navigate('/login');
    },
  };
};
```

## 🔍 코드 리뷰 체크리스트

### 구조 검증
- [ ] 올바른 레이어에 파일이 배치되었는가?
- [ ] Atomic Design 의존성 방향이 올바른가?
- [ ] 도메인 로직이 domains/ 레이어에 분리되었는가?
- [ ] 공통 코드가 shared/ 레이어에 배치되었는가?

### 컴포넌트 품질
- [ ] Props 인터페이스가 명확하게 정의되었는가?
- [ ] CSS 변수와 믹스인을 활용했는가?
- [ ] className prop을 지원하는가?
- [ ] 재사용성을 고려한 설계인가?

### 타입 안전성
- [ ] TypeScript 타입이 명시적으로 정의되었는가?
- [ ] any 타입을 사용하지 않았는가?
- [ ] 타입 import/export가 올바른가?

### 성능 최적화
- [ ] 불필요한 리렌더링이 없는가?
- [ ] 무거운 계산에 useMemo를 적용했는가?
- [ ] 큰 객체를 직접 props로 전달하지 않았는가?

## 🛠 리팩토링 가이드

### 컴포넌트 분리 시점
```typescript
// ❌ 너무 큰 컴포넌트 (100줄 이상)
const UserDashboard = () => {
  // 사용자 정보 로직 (30줄)
  // 통계 차트 로직 (30줄)  
  // 최근 활동 로직 (40줄)
  return (/* 복잡한 JSX */);
};

// ✅ Atomic Design으로 분리
const UserDashboard = () => {
  return (
    <MainLayout>
      <UserProfileSection />
      <UserStatsSection />
      <RecentActivitySection />
    </MainLayout>
  );
};
```

### 도메인 로직 분리
```typescript
// ❌ 컴포넌트에 비즈니스 로직 혼재
const LoginForm = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = async () => {
    // 복잡한 로그인 로직 (30줄)
    // 에러 처리 로직 (20줄)
    // 리다이렉트 로직 (10줄)
  };
  
  return (/* JSX */);
};

// ✅ 도메인 훅으로 분리
const LoginForm = () => {
  const { loginWithRedirect, isLoading } = useAuthActions();
  
  return (/* JSX */);
};
```

## 💡 베스트 프랙티스

### 1. 의존성 관리
- 상위 레이어는 하위 레이어를 참조 가능
- 하위 레이어는 상위 레이어를 참조 금지
- 동일 레이어 간 참조는 신중하게 결정

### 2. 상태 관리 선택
- **React State**: 컴포넌트 로컬 상태
- **TanStack Query**: 서버 상태 관리
- **Zustand**: 전역 클라이언트 상태

### 3. 코드 일관성
- 기존 코드 패턴 참고
- 네이밍 컨벤션 준수
- CSS 변수 및 믹스인 활용
- TypeScript 엄격 모드 준수

### 4. 성능 고려사항
- 컴포넌트 lazy loading
- 무거운 계산 최적화
- 불필요한 렌더링 방지
- 번들 크기 최적화

이 가이드를 통해 Vibe 프로젝트의 현재 구조를 유지하며 일관성 있는 개발을 진행할 수 있습니다.