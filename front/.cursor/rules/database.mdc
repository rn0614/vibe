---
globs: ["**/api/**/*.ts", "**/hooks/**/*.ts", "**/stores/**/*.ts"]
alwaysApply: true
---

# Vibe 프로젝트 Database & Supabase 개발 가이드

> `/shared/types/database.ts`를 기반으로 한 타입 안전한 데이터베이스 연동 가이드

## 📋 현재 Database 타입 상태

**파일 위치**: `front/src/shared/types/database.ts`

현재 상태:
```typescript
export type Database = {
  __InternalSupabase: {
    PostgrestVersion: "13.0.4"
  }
  public: {
    Tables: {
      [_ in never]: never  // 아직 테이블 없음
    }
    Views: { [_ in never]: never }
    Functions: { [_ in never]: never }
    Enums: { [_ in never]: never }
    CompositeTypes: { [_ in never]: never }
  }
}
```

## 🔧 Supabase 타입 생성 및 업데이트

### 1. **타입 생성 명령어**
```bash
# .env 파일에 VITE_SUPABASE_PROJECT_ID 설정 후
npm run supabase:types
```

### 2. **실제 DB 스키마 예시 (생성 후)**
```typescript
// database.ts (자동 생성됨)
export type Database = {
  public: {
    Tables: {
      users: {
        Row: {
          id: string;
          email: string;
          name: string | null;
          avatar_url: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          email: string;
          name?: string | null;
          avatar_url?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          email?: string;
          name?: string | null;
          avatar_url?: string | null;
          updated_at?: string;
        };
      };
      posts: {
        Row: {
          id: string;
          title: string;
          content: string;
          user_id: string;
          published: boolean;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          title: string;
          content: string;
          user_id: string;
          published?: boolean;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          title?: string;
          content?: string;
          published?: boolean;
          updated_at?: string;
        };
      };
    };
  }
}
```

## 🎯 타입 안전한 Supabase 쿼리 패턴

### 1. **기본 타입 가져오기**
```typescript
import type { Database, Tables, TablesInsert, TablesUpdate } from '@/shared/types/database';

// 타입 alias 사용
type User = Tables<'users'>;
type NewUser = TablesInsert<'users'>;
type UserUpdate = TablesUpdate<'users'>;
type Post = Tables<'posts'>;
```

### 2. **Supabase 클라이언트 타입 적용**
```typescript
// ✅ 올바른 Supabase 클라이언트 사용
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/shared/types/database';

export const supabase = createClient<Database>(
  process.env.VITE_SUPABASE_URL!,
  process.env.VITE_SUPABASE_ANON_KEY!
);

// ❌ 타입 없는 클라이언트 (금지)
export const supabase = createClient(url, key);
```

### 3. **타입 안전한 쿼리 작성**
```typescript
// ✅ 타입 안전한 SELECT
const getUsers = async (): Promise<Tables<'users'>[]> => {
  const { data, error } = await supabase
    .from('users')
    .select('*');
    
  if (error) throw error;
  return data; // 타입이 Tables<'users'>[]로 추론됨
};

// ✅ 특정 컬럼만 선택
const getUsersWithEmail = async () => {
  const { data, error } = await supabase
    .from('users')
    .select('id, email, name');
    
  if (error) throw error;
  return data; // 타입이 { id: string; email: string; name: string | null }[]로 추론됨
};

// ✅ JOIN 쿼리
const getPostsWithUsers = async () => {
  const { data, error } = await supabase
    .from('posts')
    .select(`
      *,
      users (
        id,
        name,
        email
      )
    `);
    
  if (error) throw error;
  return data;
};
```

### 4. **타입 안전한 INSERT/UPDATE/DELETE**
```typescript
// ✅ INSERT
const createUser = async (userData: TablesInsert<'users'>) => {
  const { data, error } = await supabase
    .from('users')
    .insert(userData)
    .select()
    .single();
    
  if (error) throw error;
  return data; // 타입이 Tables<'users'>로 추론됨
};

// ✅ UPDATE
const updateUser = async (id: string, updates: TablesUpdate<'users'>) => {
  const { data, error } = await supabase
    .from('users')
    .update(updates)
    .eq('id', id)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};

// ✅ DELETE
const deleteUser = async (id: string) => {
  const { error } = await supabase
    .from('users')
    .delete()
    .eq('id', id);
    
  if (error) throw error;
};
```

## 🔗 도메인별 특화 Hooks 패턴 (권장)

### ⚠️ **범용 Hooks의 한계**

기존의 범용적인 `useSupabaseQuery` 같은 접근법은 실제 프로덕션에서 다음과 같은 한계가 있습니다:

- 복잡한 JOIN 쿼리 지원 어려움
- 필터링, 정렬, 검색 로직의 복잡성
- 비즈니스 로직에 특화된 최적화 불가
- 타입 안전성 부족

### ✅ **도메인별 특화 Hooks 구조**

```
entities/
├── user/
│   ├── hooks/
│   │   └── useUsers.ts     # User 도메인 특화 hooks
│   └── index.ts
├── post/
│   ├── hooks/
│   │   └── usePosts.ts     # Post 도메인 특화 hooks
│   └── index.ts
└── ...
```

### 1. **User 도메인 Hook 예시**
```typescript
// entities/user/hooks/useUsers.ts
import { useQuery, useMutation } from '@tanstack/react-query';
import { QUERY_KEYS, handleSupabaseError } from '@/shared/hooks/useSupabaseQuery';
import type { Tables, TablesInsert } from '@/shared/types/database';

export interface UserFilters {
  status?: 'active' | 'inactive';
  role?: 'admin' | 'user';
  search?: string;
}

// 복잡한 필터링과 정렬이 포함된 사용자 조회
export const useUsers = (filters?: UserFilters) => {
  return useQuery({
    queryKey: QUERY_KEYS.users.list(filters || {}),
    queryFn: async (): Promise<Tables<'users'>[]> => {
      try {
        let query = supabase
          .from('users')
          .select('id, name, email, avatar_url, status, role, created_at');

        // 비즈니스 로직에 맞는 복잡한 필터링
        if (filters?.status) {
          query = query.eq('status', filters.status);
        }
        
        if (filters?.role) {
          query = query.eq('role', filters.role);
        }

        if (filters?.search) {
          query = query.or(`name.ilike.%${filters.search}%,email.ilike.%${filters.search}%`);
        }

        const { data, error } = await query
          .order('created_at', { ascending: false })
          .limit(50);

        if (error) handleSupabaseError(error);
        return data;
      } catch (error) {
        handleSupabaseError(error);
      }
    }
  });
};

// 사용자별 게시글 통계 포함 상세 조회
export const useUserWithStats = (userId: string) => {
  return useQuery({
    queryKey: QUERY_KEYS.users.detail(userId),
    queryFn: async () => {
      try {
        // 복잡한 JOIN과 통계 쿼리
        const [userResult, statsResult] = await Promise.all([
          supabase
            .from('users')
            .select(`
              *,
              user_profiles (
                bio, website, location
              )
            `)
            .eq('id', userId)
            .single(),
          supabase
            .from('posts')
            .select('id, status', { count: 'exact' })
            .eq('author_id', userId)
        ]);

        if (userResult.error) handleSupabaseError(userResult.error);
        
        return {
          ...userResult.data,
          stats: {
            totalPosts: statsResult.count || 0
          }
        };
      } catch (error) {
        handleSupabaseError(error);
      }
    },
    enabled: !!userId
  });
};
```

### 2. **Post 도메인 Hook 예시**
```typescript
// entities/post/hooks/usePosts.ts
export interface PostWithAuthor extends Tables<'posts'> {
  author: {
    id: string;
    name: string;
    avatar_url?: string;
  };
}

// 작성자 정보가 포함된 게시글 목록
export const usePostsWithAuthors = (filters?: PostFilters) => {
  return useQuery({
    queryKey: QUERY_KEYS.posts.list(filters || {}),
    queryFn: async (): Promise<PostWithAuthor[]> => {
      try {
        let query = supabase
          .from('posts')
          .select(`
            id, title, content, excerpt, status, published_at, created_at,
            users!posts_author_id_fkey (
              id, name, avatar_url
            )
          `);

        // 복잡한 필터링 로직
        if (filters?.status) query = query.eq('status', filters.status);
        if (filters?.category) query = query.eq('category', filters.category);
        if (filters?.search) {
          query = query.or(`title.ilike.%${filters.search}%,content.ilike.%${filters.search}%`);
        }

        const { data, error } = await query
          .order('published_at', { ascending: false, nullsFirst: false })
          .limit(20);

        if (error) handleSupabaseError(error);

        // 데이터 변환 로직
        return data.map(post => ({
          ...post,
          author: {
            id: post.users.id,
            name: post.users.name,
            avatar_url: post.users.avatar_url,
          }
        }));
      } catch (error) {
        handleSupabaseError(error);
      }
    }
  });
};
```

### 3. **Mutation Hook 패턴**
```typescript
export const useCreateUser = () => {
  const { invalidateEntityLists } = useInvalidateQueries();

  return useMutation({
    mutationFn: async (userData: TablesInsert<'users'>): Promise<Tables<'users'>> => {
      try {
        const { data, error } = await supabase
          .from('users')
          .insert(userData)
          .select()
          .single();

        if (error) handleSupabaseError(error);
        return data;
      } catch (error) {
        handleSupabaseError(error);
      }
    },
    onSuccess: () => {
      invalidateEntityLists('users');
    },
    onError: (error) => {
      console.error('사용자 생성 실패:', error);
    },
  });
};
```

### 4. **컴포넌트에서 사용**
```typescript
// components/UsersList.tsx
import { useUsers, useCreateUser } from '@/entities/user';

const UsersList = () => {
  const { 
    data: users, 
    isLoading, 
    error 
  } = useUsers({ status: 'active' });
  
  const createUserMutation = useCreateUser();

  const handleCreateUser = (userData: TablesInsert<'users'>) => {
    createUserMutation.mutate(userData, {
      onSuccess: () => {
        console.log('사용자 생성 완료');
      }
    });
  };

  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>에러: {error.message}</div>;
  
  return (
    <div>
      {users?.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

## 🛡️ 에러 핸들링 패턴

### 1. **Supabase 에러 타입 활용**
```typescript
import { PostgrestError, AuthError } from '@supabase/supabase-js';
import { ApiException } from '@/shared/api/client';

// ✅ 에러 타입 가드 사용
const handleSupabaseError = (error: unknown) => {
  if (error && typeof error === 'object' && 'code' in error) {
    const pgError = error as PostgrestError;
    
    switch (pgError.code) {
      case '23505': // unique_violation
        throw new ApiException(409, '이미 존재하는 데이터입니다.', pgError.code);
      case '23503': // foreign_key_violation
        throw new ApiException(400, '참조된 데이터가 존재하지 않습니다.', pgError.code);
      default:
        throw new ApiException(400, pgError.message, pgError.code);
    }
  }
  
  throw new ApiException(500, '알 수 없는 오류가 발생했습니다.');
};
```

### 2. **React Query 에러 처리**
```typescript
export const useUsers = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      try {
        const { data, error } = await supabase
          .from('users')
          .select('*');
          
        if (error) {
          handleSupabaseError(error);
        }
        
        return data;
      } catch (error) {
        console.error('사용자 조회 오류:', error);
        throw error;
      }
    },
    retry: (failureCount, error) => {
      // 특정 에러는 재시도하지 않음
      if (error instanceof ApiException && error.status === 404) {
        return false;
      }
      return failureCount < 3;
    }
  });
};
```

## 🚀 성능 최적화 패턴

### 1. **선택적 필드 조회**
```typescript
// ✅ 필요한 필드만 선택
const getUsersMinimal = async () => {
  const { data, error } = await supabase
    .from('users')
    .select('id, name, email'); // avatar_url, created_at 등 제외
    
  if (error) throw error;
  return data;
};

// ✅ 조건부 JOIN
const getPostsWithUserInfo = async (includeUserDetails = false) => {
  const userFields = includeUserDetails 
    ? 'id, name, email, avatar_url'
    : 'id, name';
    
  const { data, error } = await supabase
    .from('posts')
    .select(`
      id,
      title,
      content,
      created_at,
      users (${userFields})
    `);
    
  if (error) throw error;
  return data;
};
```

### 2. **페이지네이션**
```typescript
// ✅ 페이지네이션 Hook
export const useUsersPaginated = (page: number, pageSize: number = 10) => {
  return useQuery({
    queryKey: ['users', 'paginated', page, pageSize],
    queryFn: async () => {
      const from = page * pageSize;
      const to = from + pageSize - 1;
      
      const { data, error, count } = await supabase
        .from('users')
        .select('*', { count: 'exact' })
        .range(from, to)
        .order('created_at', { ascending: false });
        
      if (error) throw error;
      
      return {
        data,
        totalCount: count || 0,
        hasNextPage: to < (count || 0) - 1,
        hasPreviousPage: page > 0
      };
    }
  });
};
```

### 3. **실시간 구독**
```typescript
// ✅ Realtime 구독 Hook
export const useRealtimeUsers = () => {
  const [users, setUsers] = useState<Tables<'users'>[]>([]);
  const queryClient = useQueryClient();
  
  useEffect(() => {
    const channel = supabase
      .channel('users-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'users' },
        (payload) => {
          console.log('사용자 변경:', payload);
          
          // React Query 캐시 무효화
          queryClient.invalidateQueries({ queryKey: ['users'] });
        }
      )
      .subscribe();
      
    return () => {
      supabase.removeChannel(channel);
    };
  }, [queryClient]);
  
  return users;
};
```

## 📊 Database 개발 Best Practices

### 1. **공통 유틸리티 활용**
```typescript
// shared/hooks/useSupabaseQuery.ts 에서 제공하는 유틸리티들
import { 
  QUERY_KEYS,           // 표준화된 Query Key
  handleSupabaseError,  // 에러 처리
  useInvalidateQueries, // 쿼리 무효화
  createPaginationQuery, // 페이지네이션
  createRealtimeSubscription // 실시간 구독
} from '@/shared/hooks/useSupabaseQuery';
```

### 2. **Query Key 표준화**
```typescript
// ✅ 자동 생성되는 표준 Query Key 구조
const userKeys = createQueryKeys('users');

userKeys.all()                    // ['users']
userKeys.lists()                  // ['users', 'list']
userKeys.list({ status: 'active' })  // ['users', 'list', { status: 'active' }]
userKeys.detail('123')            // ['users', 'detail', '123']
userKeys.infinite({ search: 'john' }) // ['users', 'infinite', { search: 'john' }]
```

### 3. **타입 중심 개발**
```typescript
// ✅ 도메인별 확장 타입 정의
export interface UserWithProfile extends Tables<'users'> {
  profile?: {
    bio?: string;
    website?: string;
    location?: string;
  };
}

export interface PostWithAuthor extends Tables<'posts'> {
  author: Pick<Tables<'users'>, 'id' | 'name' | 'avatar_url'>;
}

export interface PostFilters {
  status?: 'draft' | 'published' | 'archived';
  authorId?: string;
  category?: string;
  search?: string;
}
```

### 4. **실제 복잡한 쿼리 예시**
```typescript
// ✅ 실제 프로덕션에서 필요한 복잡한 쿼리들
export const usePopularPostsWithStats = () => {
  return useQuery({
    queryKey: ['posts', 'popular', 'with-stats'],
    queryFn: async () => {
      // 복잡한 JOIN과 통계 쿼리
      const { data, error } = await supabase
        .from('posts')
        .select(`
          id, title, excerpt, published_at,
          users!posts_author_id_fkey (
            id, name, avatar_url
          ),
          post_likes (count),
          comments (count)
        `)
        .eq('status', 'published')
        .gte('published_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
        .order('post_likes(count)', { ascending: false })
        .order('comments(count)', { ascending: false })
        .limit(10);

      if (error) handleSupabaseError(error);
      return data;
    },
    staleTime: 10 * 60 * 1000 // 10분
  });
};

// ✅ 조건부 복잡한 필터링
export const useAdvancedUserSearch = (filters: AdvancedUserFilters) => {
  return useQuery({
    queryKey: QUERY_KEYS.users.list(filters),
    queryFn: async () => {
      let query = supabase
        .from('users')
        .select(`
          *,
          user_profiles (bio, website, location),
          posts (count)
        `);

      // 동적 필터링
      if (filters.search) {
        query = query.or(`
          name.ilike.%${filters.search}%,
          email.ilike.%${filters.search}%,
          user_profiles.bio.ilike.%${filters.search}%
        `);
      }

      if (filters.hasPublishedPosts) {
        query = query.gt('posts(count)', 0);
      }

      if (filters.joinedAfter) {
        query = query.gte('created_at', filters.joinedAfter);
      }

      if (filters.roles?.length) {
        query = query.in('role', filters.roles);
      }

      const { data, error } = await query
        .order(filters.sortBy || 'created_at', { 
          ascending: filters.sortDirection === 'asc' 
        })
        .limit(filters.limit || 50);

      if (error) handleSupabaseError(error);
      return data;
    }
  });
};
```

### 3. **환경별 설정**
```typescript
// ✅ 환경변수 검증
const requiredEnvVars = {
  VITE_SUPABASE_URL: process.env.VITE_SUPABASE_URL,
  VITE_SUPABASE_ANON_KEY: process.env.VITE_SUPABASE_ANON_KEY,
  VITE_SUPABASE_PROJECT_ID: process.env.VITE_SUPABASE_PROJECT_ID,
} as const;

for (const [key, value] of Object.entries(requiredEnvVars)) {
  if (!value) {
    throw new Error(`Missing required environment variable: ${key}`);
  }
}
```

## 🔄 개발 워크플로우

### 1. **DB 스키마 변경 시**
```bash
# 1. Supabase에서 스키마 변경
# 2. 타입 재생성
npm run supabase:types

# 3. 관련 TypeScript 에러 수정
# 4. 테스트 실행
npm run test

# 5. 커밋
git add src/shared/types/database.ts
git commit -m "Update database types"
```

### 2. **새 테이블 추가 시**
1. Supabase에서 테이블 생성
2. `npm run supabase:types` 실행
3. 새 테이블용 Hook 생성
4. 새 테이블용 API 함수 생성
5. Query Key 상수 추가

이 가이드를 통해 `/shared/types/database.ts`를 기반으로 한 타입 안전한 데이터베이스 개발을 수행할 수 있습니다.